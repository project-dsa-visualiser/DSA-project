<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Hashing</title>
<style>
:root{--bg:#f6f7fb;--card:#ffffff;--muted:#6b6f78;--accent1:#cde7f0;--accent2:#f7d7e0;--accent3:#e6f7d7;--accent4:#fff2cc;--primary:#5b7cfa}
*{box-sizing:border-box}body{margin:0;font-family:Inter,system-ui,Arial;background:rgba(120, 216, 243, 0.699);color:#222}
.header{display:flex;align-items:center;gap:12px;padding:14px 18px}
.container{display:grid;grid-template-columns:360px 1fr;gap:18px;padding:18px}
.panel{background:var(--card);border-radius:12px;padding:14px;box-shadow:0 8px 24px rgba(20,20,30,0.03)}
.menu{display:flex;flex-direction:column;gap:8px}
.topic-btn{padding:8px;border-radius:8px;border:1px solid rgba(0,0,0,0.06);background:#fff;cursor:pointer;text-align:left}
.topic-btn.active{background:rgba(231, 190, 241, 0.699),var(--accent4);outline:3px solid rgba(91,124,250,0.08)}
.row{display:flex;gap:8px;align-items:center}
.btn{padding:8px 10px;border-radius:8px;border:none;background:var(--primary);color:#fff;cursor:pointer}
.btn.ghost{background:transparent;border:1px solid rgba(0,0,0,0.06);color:var(--primary)}
textarea{width:100%;min-height:64px;padding:8px;border-radius:8px;border:1px solid rgba(0,0,0,0.06)}
.hash-row{display:flex;gap:8px;flex-wrap:wrap}
.bucket{flex:1 0 70px;min-width:70px;border-radius:8px;padding:8px;border:1px dashed rgba(0,0,0,0.06);background:#fff;position:relative}
.bucket.active{box-shadow:0 8px 18px rgba(91,124,250,0.06);border-style:solid}
.index{position:absolute;right:8px;top:6px;font-size:12px;color:var(--muted)}
.node{display:inline-flex;align-items:center;justify-content:center;padding:6px 10px;border-radius:10px;margin:6px 4px;background:var(--accent1);min-width:36px}
.node.tomb{background:var(--accent4)}
.node.active{outline:3px solid rgba(91,124,250,0.12)}
.footer{padding:10px;text-align:center;color:var(--muted)}
@media(max-width:900px){.container{grid-template-columns:1fr}} 
</style>
</head>
<body>
  <div class="header">
    <h2 style="margin:0">Hashing Visualizer</h2>
    <div style="flex:1"></div>
    <div style="color:var(--muted)">Now default hash = <code>%10</code> (modifiable)</div>
  </div>

  <div class="container">
    <aside class="panel">
      <label style="font-size:13px;color:var(--muted)">Topic</label>
      <div class="menu" id="topicMenu">
        <button class="topic-btn active" data-topic="chaining">Separate Chaining</button>
        <button class="topic-btn" data-topic="open">Open Addressing</button>
      </div>

      <div style="margin-top:12px">
        <label style="font-size:13px;color:var(--muted)">Hash modulus (m) — default 10 (h(x) = |x| % m)</label>
        <div class="row" style="margin-top:6px">
          <input id="hashMod" type="number" min="2" value="10" style="flex:1;padding:8px;border-radius:8px;border:1px solid rgba(0,0,0,0.06)" />
          <button id="applyHashMod" class="btn ghost">Apply</button>
        </div>
      </div>

      <div style="margin-top:12px">
        <label style="font-size:13px;color:var(--muted)">Random generator — size (1–100)</label>
        <div class="row" style="margin-top:6px">
          <input id="sizeInput" type="number" min="1" max="100" value="8" style="flex:1;padding:8px;border-radius:8px;border:1px solid rgba(0,0,0,0.06)" />
          <button id="randBtn" class="btn">Random</button>
        </div>
      </div>

      <div style="margin-top:12px">
        <label style="font-size:13px;color:var(--muted)">Custom input (comma separated)</label>
        <textarea id="customInput" placeholder="e.g. 12, 7, 26, 33"></textarea>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="loadCustom" class="btn ghost">Load</button>
          <button id="clearBtn" class="btn ghost">Clear</button>
        </div>
      </div>

      <div style="margin-top:12px">
        <label style="font-size:13px;color:var(--muted)">Open addressing method (only for Open Addressing)</label>
        <select id="oaMethod" style="width:100%;padding:8px;border-radius:8px;border:1px solid rgba(0,0,0,0.06);margin-top:6px">
          <option value="linear">Linear Probing</option>
          <option value="quadratic">Quadratic Probing</option>
          <option value="double">Double Hashing</option>
        </select>
      </div>

      <div style="margin-top:12px">
        <label style="font-size:13px;color:var(--muted)">Operation</label>
        <div class="row" style="margin-top:6px">
          <button id="insertMode" class="btn">Insert</button>
          <button id="searchMode" class="btn ghost">Search</button>
          <button id="deleteMode" class="btn ghost">Delete</button>
        </div>
        <div class="row" style="margin-top:8px">
          <input id="valueInput" type="number" placeholder="value" style="flex:1;padding:8px;border-radius:8px;border:1px solid rgba(0,0,0,0.06)" />
          <button id="doOp" class="btn">Run</button>
        </div>
      </div>

      <div style="margin-top:12px">
        <label style="font-size:13px;color:var(--muted)">Controls</label>
        <div class="row" style="margin-top:6px">
          <button id="resetBtn" class="btn ghost">Reset</button>
          <button id="clearTableBtn" class="btn ghost">Clear Table</button>
        </div>
      </div>

    </aside>

    <main class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <div>
          <strong id="topicTitle">Separate Chaining</strong>
          <div id="topicDesc" style="font-size:13px;color:var(--muted)">Buckets with linked lists to handle collisions</div>
        </div>
        <div style="text-align:right">
          <div style="font-size:13px;color:var(--muted)">Table size (m): <strong id="tableSize">10</strong></div>
          <div style="font-size:13px;color:var(--muted)">Load: <strong id="loadFactor">0%</strong></div>
        </div>
      </div>

      <div id="vizArea">
        <div id="buckets" class="hash-row"></div>
      </div>

      <div style="display:flex;gap:12px;margin-top:12px">
        <div id="log" class="panel" style="flex:1;min-height:80px;overflow:auto"></div>
        <div style="width:160px;text-align:center;align-self:flex-start">
          <div style="font-size:13px;color:var(--muted)">Steps</div>
          <div id="stepCount" style="font-size:22px">0</div>
        </div>
      </div>

      <div class="footer">Default hash = |x| % 10. Use 'Apply' to change modulus. For Open Addressing, tombstones are used for deletion.</div>
    </main>
  </div>

<script>
(function(){
  
  const DEFAULT_MOD = 10;
  let MOD = DEFAULT_MOD;            
  let topic = 'chaining';          
  let oaMethod = 'linear';

 
  let chains = [];                 
  let table = [];                  

  
  const topicMenu = document.getElementById('topicMenu');
  const bucketsEl = document.getElementById('buckets');
  const tableSizeEl = document.getElementById('tableSize');
  const loadFactorEl = document.getElementById('loadFactor');
  const hashModInput = document.getElementById('hashMod');
  const applyHashMod = document.getElementById('applyHashMod');
  const randBtn = document.getElementById('randBtn');
  const sizeInput = document.getElementById('sizeInput');
  const customInput = document.getElementById('customInput');
  const loadCustom = document.getElementById('loadCustom');
  const clearBtn = document.getElementById('clearBtn');
  const oaSelect = document.getElementById('oaMethod');
  const insertMode = document.getElementById('insertMode');
  const searchMode = document.getElementById('searchMode');
  const deleteMode = document.getElementById('deleteMode');
  const valueInput = document.getElementById('valueInput');
  const doOp = document.getElementById('doOp');
  const resetBtn = document.getElementById('resetBtn');
  const clearTableBtn = document.getElementById('clearTableBtn');
  const logEl = document.getElementById('log');
  const stepCountEl = document.getElementById('stepCount');
  const topicTitle = document.getElementById('topicTitle');
  const topicDesc = document.getElementById('topicDesc');

  let mode = 'insert';
  let stepCount = 0;

  
  function log(msg){ const d = document.createElement('div'); d.textContent = msg; logEl.appendChild(d); logEl.scrollTop = logEl.scrollHeight; }
  function updateStep(){ stepCountEl.textContent = stepCount; }

  
  function primaryHash(x){ const n = Number(x)||0; return Math.abs(Math.floor(n)) % MOD; }
  function secondHash(x){ const n = Number(x)||0; return 1 + (Math.abs(Math.floor(n)) % Math.max(1, MOD-1)); }

  
  function initStructures(m){ MOD = m || DEFAULT_MOD; chains = Array.from({length:MOD}, ()=>[]); table = Array.from({length:MOD}, ()=>({val:null,state:'empty'})); tableSizeEl.textContent = MOD; updateLoad(); render(); }

  function render(){ bucketsEl.innerHTML = ''; for(let i=0;i<MOD;i++){ const b = document.createElement('div'); b.className='bucket'; b.dataset.index=i; const idx = document.createElement('div'); idx.className='index'; idx.textContent = i; b.appendChild(idx);
      if(topic==='chaining'){
        const list = chains[i]; list.forEach(v=>{ const n = document.createElement('div'); n.className='node'; n.textContent = v; b.appendChild(n); });
      } else {
        const e = table[i]; if(e.state==='filled'){ const n = document.createElement('div'); n.className='node'; n.textContent = e.val; b.appendChild(n); }
        else if(e.state==='tombstone'){ const n = document.createElement('div'); n.className='node tomb'; n.textContent = 'T'; b.appendChild(n); }
      }
      bucketsEl.appendChild(b);
  } }

  function updateLoad(){ const filled = (topic==='chaining') ? chains.reduce((s,a)=>s+a.length,0) : table.filter(e=>e.state==='filled').length; const load = Math.round((filled / MOD)*100); loadFactorEl.textContent = load + '%'; }

  
  function insertValue(v){ v = Number(v);
    const h = primaryHash(v); log(`h(${v}) => ${h}`); stepCount++; updateStep();
    if(topic==='chaining'){
      chains[h].push(v); log(`Inserted ${v} into chain ${h}`); render(); updateLoad(); return true;
    } else {
      
      const method = oaMethod;
      const step = (method==='double')? secondHash(v): null;
      let firstTomb = -1;
      for(let i=0;i<MOD;i++){
        const idx = (method==='linear')? (h+i)%MOD : (method==='quadratic')? (h + i*i)%MOD : (h + i*(step))%MOD;
        const entry = table[idx]; log(`Probe ${i} -> ${idx}`);
        if(entry.state==='filled'){
          if(entry.val===v){ log(`${v} already present at ${idx} — skipping insert`); return false; }
          continue;
        }
        if(entry.state==='tombstone'){ if(firstTomb===-1) firstTomb = idx; continue; }
        if(entry.state==='empty'){ const dest = (firstTomb!==-1)? firstTomb: idx; table[dest] = {val:v,state:'filled'}; log(`Placed ${v} at ${dest}`); render(); updateLoad(); return true; }
      }
      
      if(firstTomb!==-1){ table[firstTomb] = {val:v,state:'filled'}; log(`Placed ${v} at tombstone ${firstTomb}`); render(); updateLoad(); return true; }
      log('Insert failed: table full'); return false;
    }
  }

  function searchValue(v){ v = Number(v); const h = primaryHash(v); log(`h(${v}) => ${h}`); stepCount++; updateStep();
    if(topic==='chaining'){
      const list = chains[h]; for(let i=0;i<list.length;i++){ log(`Compare chain[${h}][${i}] = ${list[i]}`); if(list[i]===v){ log(`Found ${v} in chain ${h} at position ${i}`); return {found:true,index:h,pos:i}; } }
      log(`${v} not found in chain ${h}`); return {found:false};
    } else {
      const method = oaMethod; const step = (method==='double')? secondHash(v): null;
      for(let i=0;i<MOD;i++){
        const idx = (method==='linear')? (h+i)%MOD : (method==='quadratic')? (h + i*i)%MOD : (h + i*(step))%MOD;
        const entry = table[idx]; log(`Probe ${i} -> ${idx}`);
        if(entry.state==='filled' && entry.val===v){ log(`Found ${v} at ${idx}`); return {found:true,index:idx}; }
        if(entry.state==='empty'){ log(`Stopped at empty ${idx} — not found`); return {found:false}; }
        
      }
      log(`Scanned table — ${v} not found`); return {found:false};
    }
  }

  function deleteValue(v){ v = Number(v); const h = primaryHash(v); log(`h(${v}) => ${h}`); stepCount++; updateStep();
    if(topic==='chaining'){
      const list = chains[h]; for(let i=0;i<list.length;i++){ log(`Compare chain[${h}][${i}] = ${list[i]}`); if(list[i]===v){ list.splice(i,1); log(`Removed ${v} from chain ${h}`); render(); updateLoad(); return {deleted:true}; } }
      log(`${v} not found in chain ${h}`); return {deleted:false};
    } else {
      const method = oaMethod; const step = (method==='double')? secondHash(v): null;
      for(let i=0;i<MOD;i++){
        const idx = (method==='linear')? (h+i)%MOD : (method==='quadratic')? (h + i*i)%MOD : (h + i*(step))%MOD;
        const entry = table[idx]; log(`Probe ${i} -> ${idx}`);
        if(entry.state==='filled' && entry.val===v){ table[idx] = {val:null,state:'tombstone'}; log(`Deleted ${v} at ${idx} (tombstone)`); render(); updateLoad(); return {deleted:true}; }
        if(entry.state==='empty'){ log(`Stopped at empty ${idx} — not found`); return {deleted:false}; }
      }
      log(`Scanned table — ${v} not found`); return {deleted:false};
    }
  }

  
  topicMenu.addEventListener('click', (e)=>{ const btn = e.target.closest('.topic-btn'); if(!btn) return; document.querySelectorAll('.topic-btn').forEach(b=>b.classList.remove('active')); btn.classList.add('active'); topic = btn.dataset.topic; topicTitle.textContent = (topic==='chaining')? 'Separate Chaining' : 'Open Addressing'; topicDesc.textContent = (topic==='chaining')? 'Buckets with linked lists to handle collisions' : 'Open addressing with probing'; render(); updateLoad(); });
  oaSelect.addEventListener('change', ()=>{ oaMethod = oaSelect.value; log('OA method set to ' + oaMethod); });

  insertMode.addEventListener('click', ()=>{ setMode('insert'); }); searchMode.addEventListener('click', ()=>{ setMode('search'); }); deleteMode.addEventListener('click', ()=>{ setMode('delete'); });
  function setMode(m){ mode = m; [insertMode,searchMode,deleteMode].forEach(b=>b.classList.remove('ghost')); if(m==='insert') insertMode.classList.add('btn'); if(m==='search') searchMode.classList.add('btn'); if(m==='delete') deleteMode.classList.add('btn'); 
    [insertMode,searchMode,deleteMode].forEach(b=>{ if(!b.classList.contains('btn')) b.classList.add('ghost'); });
    
    if(m==='insert'){ insertMode.classList.remove('ghost'); insertMode.classList.add('btn'); }
    if(m==='search'){ searchMode.classList.remove('ghost'); searchMode.classList.add('btn'); }
    if(m==='delete'){ deleteMode.classList.remove('ghost'); deleteMode.classList.add('btn'); }
  }

  doOp.addEventListener('click', ()=>{ const v = valueInput.value; if(v===''){ alert('Enter a numeric value'); return; } if(mode==='insert'){ insertValue(v); } else if(mode==='search'){ searchValue(v); } else if(mode==='delete'){ deleteValue(v); } render(); });

  hashModInput.addEventListener('change', ()=>{});
  applyHashMod.addEventListener('click', ()=>{ const m = Math.max(2, Math.floor(Number(hashModInput.value) || DEFAULT_MOD)); initStructures(m); log('Hash modulus changed to ' + MOD); });

  randBtn.addEventListener('click', ()=>{ const n = Math.min(100,Math.max(1,Number(sizeInput.value)||8)); const arr = Array.from({length:n}, ()=>Math.floor(Math.random()*100)); loadArray(arr); });
  loadCustom.addEventListener('click', ()=>{ const raw = customInput.value.trim(); if(!raw){ alert('Enter comma separated numbers'); return; } const arr = raw.split(',').map(s=>Number(s.trim())).filter(x=>!Number.isNaN(x)); if(arr.length===0){ alert('No valid numbers found'); return; } loadArray(arr); });
  clearBtn.addEventListener('click', ()=>{ customInput.value=''; });

  resetBtn.addEventListener('click', ()=>{ logEl.innerHTML=''; stepCount=0; updateStep(); initStructures(DEFAULT_MOD); });
  clearTableBtn.addEventListener('click', ()=>{ initStructures(MOD); log('Cleared table'); });

  function loadArray(arr){ log('Loading array: ' + arr.join(', ')); stepCount=0; updateStep(); initStructures(Math.max(MOD, arr.length*2)); 
    
    for(const v of arr){ insertValue(v); }
    render(); updateLoad(); }

  
  initStructures(DEFAULT_MOD);
  setMode('insert');
  updateStep();

  
  window.HV = {insertValue,searchValue,deleteValue,initStructures,chains,table,primaryHash,secondHash};

})();
</script>
</body>
</html>