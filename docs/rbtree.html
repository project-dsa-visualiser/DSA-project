<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Red-Black Tree Visualizer</title>
<style>
  :root{ --bg:#bad5fa; --panel:#ffffff; --muted:#9aa3b2; --accent:#6b8cff; --shadow:0 6px 18px rgba(15,23,42,0.06); }
  *{box-sizing:border-box;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#f1f4fb);color:#223;overflow:hidden;}
  header{padding:14px 18px;display:flex;align-items:center;gap:12px}
  header h1{margin:0;font-size:17px}
  .container{display:grid;grid-template-columns:320px 1fr;gap:14px;padding:14px;height:calc(100vh - 78px); }
  .menu{background:var(--panel);border-radius:12px;padding:12px;box-shadow:var(--shadow);overflow:auto}
  .controls{background:var(--panel);border-radius:12px;padding:10px;box-shadow:var(--shadow);margin-bottom:10px}
  .canvas-wrap{
    background:linear-gradient(180deg,#fbfdff,#f6f8ff);
    border-radius:12px;
    padding:10px;
    max-height: calc(100vh - 160px);
    max-width:1200px;
    overflow:auto;
  }
  svg{ display:block; width:max-content; min-width:1200px; min-height: calc(100vh - 220px); }
  input,select,button{font-size:13px}
  button{
    padding:6px 12px;
    background:var(--accent);
    color:#fff;
    border:none;
    border-radius:8px;
    cursor:pointer;
    transition:0.2s;
  }
  button:hover{opacity:0.85}
  button:active{transform:scale(0.96)}
  button.ghost{
    background:transparent;
    color:var(--accent);
    border:1px dashed rgba(107,140,255,0.7);
  }
  button.ghost:hover{
    background:rgba(107,140,255,0.08);
  }
  .node{filter:drop-shadow(0 6px 14px rgba(20,30,60,0.06));transform-origin:center center}
  .node circle{transition:fill 300ms ease, r 300ms ease, opacity 300ms ease}
  .node text{transition:fill 300ms ease}
  .highlight circle{stroke:#ffd966;stroke-width:3}
  .fade-out{transition:opacity 400ms ease;opacity:0}
  .status{font-size:13px;color:#6c7a89}
  footer{padding:12px;text-align:center;color:var(--muted)}
  .line.current{background:linear-gradient(90deg,#fff1a8,#fff8e6);border-left:4px solid #ffd966}
  .row {display:flex; gap:8px; align-items:center;}
</style>
</head>
<body>
<header>
  <div style="width:40px;height:40px;border-radius:10px;background:#efe2ff;display:flex;align-items:center;justify-content:center"><strong style="color:#6b44ff">DSA</strong></div>
  <div><h1>Red-Black Tree Visualizer — Compact</h1>
    <div style="color:#6c7a89;font-size:13px">Insert / Delete / Traverse (in/pre/post) — compact layout</div>
  </div>
</header>

<div class="container">
  <aside class="menu">
    <div style="font-weight:600;margin-bottom:8px">Controls</div>

    <div style="margin-bottom:8px">
      <input id="customInput" placeholder="e.g. 10,5,20" style="width:100%" />
    </div>

    <div class="row" style="margin-bottom:8px">
      <button id="applyInput">Apply</button>
      <button id="randomGen" class="ghost">Random</button>
      <input id="randSize" type="number" value="7" min="1" max="80" style="width:72px" />
    </div>

    <div class="row" style="margin-bottom:8px;align-items:center">
      <label style="margin-right:6px">Speed</label>
      <input id="speed" type="range" min="0.25" max="3" step="0.05" value="1" style="flex:1" />
      <span id="speedVal">1.00x</span>
    </div>

    <div class="row" style="margin-bottom:8px">
      <button id="insertBtn">Insert Next</button>
      <button id="deleteBtn">Delete</button>
      <button id="clearBtn" class="ghost">Clear</button>
    </div>

    <div style="margin-bottom:8px">
      <label>Traversal:
        <select id="traversalMode" style="margin-left:6px">
          <option value="inorder">In-order</option>
          <option value="preorder">Pre-order</option>
          <option value="postorder">Post-order</option>
        </select>
      </label>
      <div style="margin-top:6px" class="row">
        <button id="traverseBtn">Traverse</button>
        <button id="playBtn" class="ghost" title="Play / Resume">Play</button>
        <button id="pauseBtn" class="ghost" title="Pause">Pause</button>
      </div>
    </div>

    <div style="font-size:13px;color:#6c7a89">Show NIL <input id="showNIL" type="checkbox" checked /></div>
  </aside>

  <main>
    <div class="controls">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>Topic: <strong>Red-Black Tree</strong></div>
        <div id="statusText" class="status">Idle</div>
      </div>
    </div>

    <div class="canvas-wrap"><svg id="svgCanvas" viewBox="0 0 1200 500" preserveAspectRatio="xMidYMin meet"></svg></div>

    <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
      <div>Nodes: <span id="nodeCount">0</span></div>
      <div style="margin-left:auto;color:#6c7a89">Tip: generate random nodes, then Traverse or Delete to see animations</div>
    </div>
  </main>
</div>

<script>
(() => {

  const svg = document.getElementById('svgCanvas');
  const customInput = document.getElementById('customInput');
  const applyInput = document.getElementById('applyInput');
  const randomGen = document.getElementById('randomGen');
  const randSize = document.getElementById('randSize');
  const speedInput = document.getElementById('speed');
  const speedVal = document.getElementById('speedVal');
  const insertBtn = document.getElementById('insertBtn');
  const deleteBtn = document.getElementById('deleteBtn');
  const clearBtn = document.getElementById('clearBtn');
  const traversalMode = document.getElementById('traversalMode');
  const traverseBtn = document.getElementById('traverseBtn');
  const playBtn = document.getElementById('playBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const showNIL = document.getElementById('showNIL');
  const statusText = document.getElementById('statusText');
  const nodeCountSpan = document.getElementById('nodeCount');

  speedInput.addEventListener('input', () => {
    speedVal.textContent = Number(speedInput.value).toFixed(2) + 'x';
  });

  class RBNode {
    constructor(val) {
      this.val = val;
      this.color = 'RED';
      this.left = null;
      this.right = null;
      this.parent = null;
      this.id = 'n' + Math.random().toString(36).slice(2,9);
      this.x = 0; this.y = 0;
    }
    isRed(){ return this.color === 'RED'; }
    isBlack(){ return this.color === 'BLACK'; }
  }

  const RBT = {
    root: null,
    actions: [],
    historyIndex: -1,
    reset() {
      this.root = null;
      this.actions = [];
      this.historyIndex = -1;
      clearSVG();
      nodeCountSpan.textContent = '0';
      statusText.textContent = 'Idle';
    }
  };

  function clearSVG(){ svg.innerHTML = ''; }

  function makeLine(x1,y1,x2,y2,dashed=false){
    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    // offsets adjusted for smaller nodes and reduced vertical gap
    line.setAttribute('x1', x1); line.setAttribute('y1', y1+8);
    line.setAttribute('x2', x2); line.setAttribute('y2', y2-8);
    line.setAttribute('stroke', '#b7c2d6'); line.setAttribute('stroke-width','1');
    if (dashed) line.setAttribute('stroke-dasharray','5,3');
    return line;
  }

  function makeNodeGroup(node){
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.setAttribute('data-id', node.id);
    g.setAttribute('transform', `translate(${node.x},${node.y})`);
    g.classList.add('node');

    const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
    circle.setAttribute('r', 20);
    circle.setAttribute('cx', 0); circle.setAttribute('cy', 0);
    circle.setAttribute('fill', node.isRed() ? '#ffb6b6' : '#111');
    circle.setAttribute('stroke', node.isRed() ? '#e45555' : '#000');

    const txt = document.createElementNS('http://www.w3.org/2000/svg','text');
    txt.textContent = node.val;
    txt.setAttribute('x',0); txt.setAttribute('y',0);
    txt.setAttribute('text-anchor','middle'); txt.setAttribute('dominant-baseline','middle');
    txt.setAttribute('font-size','16'); txt.setAttribute('font-weight','600');
    txt.setAttribute('fill', node.isRed()? '#5b1d1d' : '#fff');

    g.appendChild(circle); g.appendChild(txt);

    g.style.transform = `translate(${node.x}px, ${node.y}px) scale(0.01)`;
    requestAnimationFrame(() => {
      g.style.transition = `transform ${420/Number(speedInput.value||1)}ms cubic-bezier(.22,.9,.24,1)`;
      g.style.transform = `translate(${node.x}px, ${node.y}px) scale(1)`;
    });

    return g;
  }

  function makeNil(x,y){
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.setAttribute('transform', `translate(${x},${y})`);
    const r = document.createElementNS('http://www.w3.org/2000/svg','rect');
    r.setAttribute('x', -7); r.setAttribute('y', -7); r.setAttribute('width', 14); r.setAttribute('height', 14);
    r.setAttribute('rx', 5); r.setAttribute('fill', '#fff'); r.setAttribute('stroke', '#cfd9e9');
    const t = document.createElementNS('http://www.w3.org/2000/svg','text');
    t.textContent = 'NIL'; t.setAttribute('x',0); t.setAttribute('y',0);
    t.setAttribute('text-anchor','middle'); t.setAttribute('dominant-baseline','middle');
    t.setAttribute('font-size','9'); t.setAttribute('fill','#8c98a8');
    g.appendChild(r); g.appendChild(t);
    return g;
  }

  function layoutTree(root){
    if (!root) return;
    function size(n){ if(!n) return 1; return size(n.left) + size(n.right); }
    const sz = size(root);
    function layout(n, x, y, w){
      if(!n) return;
      n.x = x; n.y = y;
      // decreased vertical gap and reduced horizontal spacing between siblings
      const half = Math.max(24, w/3); // use w/3 instead of w/2 to bring siblings closer
      layout(n.left, x - half, y + 36, w/2);
      layout(n.right, x + half, y + 36, w/2);
    }
    // reduce overall tree width so tree appears smaller
    layout(root, 600, 50, Math.min(1400, sz * 50));
  }

  function drawTree(root){
    clearSVG();
    if (!root) return;
    layoutTree(root);

    function drawEdges(n){
      if(!n) return;
      if(n.left){
        svg.appendChild(makeLine(n.x,n.y,n.left.x,n.left.y));
        drawEdges(n.left);
      } else if (showNIL.checked){
        svg.appendChild(makeLine(n.x,n.y,n.x-50,n.y+36,true));
        svg.appendChild(makeNil(n.x-50,n.y+36));
      }
      if(n.right){
        svg.appendChild(makeLine(n.x,n.y,n.right.x,n.right.y));
        drawEdges(n.right);
      } else if (showNIL.checked){
        svg.appendChild(makeLine(n.x,n.y,n.x+50,n.y+36,true));
        svg.appendChild(makeNil(n.x+50,n.y+36));
      }
    }
    drawEdges(root);

    function drawNodes(n){
      if(!n) return;
      drawNodes(n.left);
      svg.appendChild(makeNodeGroup(n));
      drawNodes(n.right);
    }
    drawNodes(root);
    nodeCountSpan.textContent = RBT.collectNodes(root).length;
  }

  function bstInsert(node){
    let y = null;
    let x = RBT.root;
    while(x){
      y = x;
      if (node.val < x.val) x = x.left;
      else x = x.right;
    }
    node.parent = y;
    if (!y) RBT.root = node;
    else if (node.val < y.val) y.left = node;
    else y.right = node;
  }

  function clone(root){
    if(!root) return null;
    function c(n){
      if(!n) return null;
      const o = { val: n.val, color: n.color, id: n.id };
      o.left = c(n.left); if (o.left) o.left.parent = o;
      o.right = c(n.right); if (o.right) o.right.parent = o;
      return o;
    }
    return c(root);
  }

  function collectTraversal(mode, node, acc){
    if(!node) return;
    if (mode === 'preorder'){
      acc.push(node);
      collectTraversal(mode, node.left, acc);
      collectTraversal(mode, node.right, acc);
    } else if (mode === 'inorder'){
      collectTraversal(mode, node.left, acc);
      acc.push(node);
      collectTraversal(mode, node.right, acc);
    } else {
      collectTraversal(mode, node.left, acc);
      collectTraversal(mode, node.right, acc);
      acc.push(node);
    }
  }

  function highlightNode(id){
    const g = svg.querySelector(`[data-id='${id}']`);
    if(!g) return;
    g.classList.add('highlight');
    const circle = g.querySelector('circle'); if(circle) circle.setAttribute('r', 10);
  }

  function unhighlightNode(id){
    const g = svg.querySelector(`[data-id='${id}']`);
    if(!g) return;
    g.classList.remove('highlight');
    const circle = g.querySelector('circle'); if(circle) circle.setAttribute('r', 8);
  }

  function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }

  function insertSingle(val){
    if (!Number.isFinite(Number(val))) return;
    const node = new RBNode(Number(val));
    node.color = 'RED';
    if (!RBT.root){
      node.color = 'BLACK';
      RBT.root = node;
      RBT.actions.push({ type:'insert', note:`insert ${val}`, snapshot: clone(RBT.root) });
    } else {
      bstInsert(node);
      RBT.actions.push({ type:'insert', note:`insert ${val}`, snapshot: clone(RBT.root) });
      if (node.parent && node.parent.isRed && node.parent.isRed){
        node.parent.color = 'BLACK';
        RBT.actions.push({ type:'recolor-parent', note:'parent recolored', snapshot: clone(RBT.root) });
      }
    }
  }

  const traversalState = {
    isRunning: false,
    isPaused: false,
    order: [],
    index: 0,
    mode: ''
  };

  async function traversalLoop(){
    if (traversalState.isRunning) return;
    traversalState.isRunning = true;
    statusText.textContent = `Traversing (${traversalState.mode})`;
    while (traversalState.index < traversalState.order.length){
      if (traversalState.isPaused){
        statusText.textContent = 'Paused';
        await new Promise(resolve => {
          const check = setInterval(() => {
            if (!traversalState.isPaused) {
              clearInterval(check);
              resolve();
            }
          }, 80);
        });
        statusText.textContent = `Traversing (${traversalState.mode})`;
      }
      const node = traversalState.order[traversalState.index];
      highlightNode(node.id);
      await sleep(520 / Number(speedInput.value || 1));
      unhighlightNode(node.id);
      traversalState.index++;
    }
    traversalState.isRunning = false;
    traversalState.order = [];
    traversalState.index = 0;
    traversalState.mode = '';
    statusText.textContent = 'Traversal done';
  }

  async function animateTraversal(mode){
    if (!RBT.root) return;
    if (traversalState.isRunning && !traversalState.isPaused) return;
    traversalState.order = [];
    collectTraversal(mode, RBT.root, traversalState.order);
    traversalState.index = 0;
    traversalState.mode = mode;
    traversalState.isPaused = false;
    await traversalLoop();
  }

  function stopTraversal(){ traversalState.isPaused = false; traversalState.isRunning = false; traversalState.order = []; traversalState.index = 0; }

  async function animateDelete(val){
    if (!RBT.root) return;
    statusText.textContent = `Deleting ${val}`;
    const z = RBT.find(val);
    if (!z) { statusText.textContent = 'Not found'; return; }

    highlightNode(z.id);
    await sleep(360 / Number(speedInput.value || 1));

    if (z.left && z.right){
      let s = z.right;
      while(s.left) s = s.left;
      highlightNode(s.id);
      await sleep(240 / Number(speedInput.value || 1));

      const g1 = svg.querySelector(`[data-id='${z.id}']`), g2 = svg.querySelector(`[data-id='${s.id}']`);
      if (g1 && g2){
        const t1 = g1.querySelector('text'), t2 = g2.querySelector('text');
        t1.style.transition = 'transform 180ms ease'; t2.style.transition = 'transform 180ms ease';
        t1.style.transform = 'scale(1.08)'; t2.style.transform = 'scale(1.08)';
        await sleep(160);
        const tmp = z.val; z.val = s.val; s.val = tmp;
        t1.textContent = z.val; t2.textContent = s.val;
        await sleep(140);
        t1.style.transform = 'scale(1)'; t2.style.transform = 'scale(1)';
      }

      unhighlightNode(s.id);
      await sleep(160 / Number(speedInput.value || 1));
      unhighlightNode(z.id);
      await sleep(80);

      await animateRemoveNode(s);
    } else {
      await animateRemoveNode(z);
    }

    statusText.textContent = 'Delete finished';
    drawTree(RBT.root);
  }

  async function animateRemoveNode(node){
    highlightNode(node.id);
    await sleep(180 / Number(speedInput.value || 1));
    const g = svg.querySelector(`[data-id='${node.id}']`);
    if (g) g.classList.add('fade-out');
    await sleep(320 / Number(speedInput.value || 1));

    const vals = RBT.collectNodes(RBT.root).map(n => n.val);
    const idx = vals.indexOf(node.val);
    if (idx > -1) vals.splice(idx, 1);
    RBT.root = null; RBT.actions = []; RBT.historyIndex = -1;
    for (const v of vals){
      const nn = new RBNode(v);
      nn.color = 'RED';
      if (!RBT.root) { nn.color = 'BLACK'; RBT.root = nn; }
      else bstInsert(nn);
    }
    drawTree(RBT.root);
  }

  RBT.find = function(val){
    let cur = this.root;
    while(cur){
      if (cur.val === val) return cur;
      cur = val < cur.val ? cur.left : cur.right;
    }
    return null;
  };

  RBT.collectNodes = function(node){
    if (!node) return [];
    return [...this.collectNodes(node.left), node, ...this.collectNodes(node.right)];
  };

  applyInput.addEventListener('click', () => {
    const s = customInput.value.trim(); if (!s) return;
    const arr = s.split(/[, ]+/).map(x => Number(x)).filter(x => Number.isFinite(x));
    for (const v of arr) insertSingle(v);
    drawTree(RBT.root);
    statusText.textContent = `Recorded ${arr.length} inserts`;
  });

  randomGen.addEventListener('click', () => {
    const n = Math.max(1, Math.min(80, Number(randSize.value) || 7));
    const arr = [];
    for (let i=0;i<n;i++) arr.push(Math.floor(Math.random()*100));
    customInput.value = arr.join(',');
    applyInput.click();
  });

  insertBtn.addEventListener('click', () => {
    const s = customInput.value.trim();
    if (!s) { statusText.textContent = 'Enter number'; return; }
    const first = Number(s.split(/[, ]+/)[0]);
    if (!Number.isFinite(first)) { statusText.textContent = 'Invalid number'; return; }
    insertSingle(first);
    drawTree(RBT.root);
    statusText.textContent = `Inserted ${first}`;
  });

  deleteBtn.addEventListener('click', () => {
    const s = customInput.value.trim();
    if (!s) { statusText.textContent = 'Enter number'; return; }
    const first = Number(s.split(/[, ]+/)[0]);
    if (!Number.isFinite(first)) { statusText.textContent = 'Invalid number'; return; }
    animateDelete(first);
  });

  clearBtn.addEventListener('click', () => {
    RBT.reset();
    drawTree(RBT.root);
    statusText.textContent = 'Cleared';
  });

  traverseBtn.addEventListener('click', () => {
    traversalState.isPaused = false;
    traversalState.order = [];
    traversalState.index = 0;
    animateTraversal(traversalMode.value);
  });

  playBtn.addEventListener('click', () => {
    if (!traversalState.order || traversalState.order.length === 0) {
      animateTraversal(traversalMode.value);
      return;
    }
    if (traversalState.isPaused) {
      traversalState.isPaused = false;
      traversalLoop().catch(()=>{});
    }
  });

  pauseBtn.addEventListener('click', () => {
    if (traversalState.isRunning) {
      traversalState.isPaused = true;
    }
  });

  RBT.reset();
  customInput.value = '10,5,20,3,8,15,30';
  applyInput.click();

  window.stopTraversal = stopTraversal;

})();
</script>

</body>

</html>
