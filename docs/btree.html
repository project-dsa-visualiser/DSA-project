<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>B-Tree Visualizer</title>
<style>
  :root{
    --bg:#c7daf7;
    --card:#d6eaef;
    --muted:#6b7280;
    --pastel1:#f7cef8;
    --pastel2:#cfe7ff;
    --pastel3:#e8ffd6;
    --blue-1:#bcdcff;
    --blue-ink:#073b6c;
    --shadow: 0 6px 20px rgba(40,40,60,0.08);
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  html,body{height:100%; margin:0; background:var(--bg); color:#0f1724;}
  .app { max-width:1200px; margin:20px auto; padding:18px; display:grid; gap:18px; grid-template-columns: 340px 1fr; }
  .panel { background:var(--card); border-radius:14px; box-shadow:var(--shadow); padding:16px; }
  h2 { margin: 6px 0 12px 0; font-size:20px; color:#0f1724; }
  label { display:block; font-size:13px; color:var(--muted); margin-bottom:6px; }
  .row { display:flex; gap:8px; align-items:center; margin-bottom:10px; }
  input[type="number"], input[type="text"], select { width:100%; padding:8px 10px; border-radius:10px; border:1px solid #e6eef6; background:transparent; font-size:14px; }
  button { border: none; padding: 10px 12px; border-radius: 10px; cursor: pointer; font-weight: 600; transition: 0.18s ease; }
  .btn-primary { background: var(--blue-1); color: var(--blue-ink); box-shadow: 0 6px 18px rgba(80,120,200,0.12); }
  .btn-ghost { background: transparent; border: 1px solid var(--blue-1); color: var(--blue-ink); padding:8px 10px; border-radius:8px; }
  .controls { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
  .small { padding:6px 8px; font-size:13px; border-radius:8px; }

  .vis { background: linear-gradient(180deg, rgba(255,255,255,0.94), rgba(250,250,255,0.82)); border-radius:14px; box-shadow:var(--shadow); min-height:520px; overflow:auto; padding:16px; }
  #canvas { width:100%; height:700px; display:block; }

  .legend { display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-top:10px; }
  .badge { padding:8px 10px; border-radius:999px; font-size:12px; display:flex; gap:8px; align-items:center; border:1px solid rgba(0,0,0,0.04); }

  .node { fill: #fff; stroke: rgba(0,0,0,0.06); rx:10; }
  .keyRect { rx:8; stroke: rgba(0,0,0,0.06); stroke-width:0.8; }
  .state-default { fill: #ffffff; }
  .state-active { fill: var(--pastel2); }
  .state-splitting { fill: var(--pastel1); }
  .state-final { fill: var(--pastel3); }
  .keyText { font-size:13px; fill:#0f1724; font-weight:600; pointer-events:none; }
  .smallText { font-size:12px; fill:var(--muted); }

  @media (max-width:900px){ .app { grid-template-columns: 1fr; padding:12px; } #canvas { height:520px; } }
</style>
</head>
<body>
<div class="app">
  <div class="panel">
    <h2>B-Tree Visualizer</h2>

    <div class="row">
      <div style="flex:1">
        <label>Minimum degree (t)</label>
        <select id="degree">
          <option value="2">t = 2 (max keys 3)</option>
          <option value="3" selected>t = 3 (max keys 5)</option>
          <option value="4">t = 4 (max keys 7)</option>
        </select>
      </div>
    </div>

    <label>Data input (single value OR comma-separated list)</label>
    <div class="row" style="gap:6px;">
      <input id="dataInput" type="text" placeholder="e.g. 15 or 10,20,5,30" />
      <button id="loadCustom" class="btn-primary small">Load</button>
    </div>

    <label>Random generator</label>
    <div class="row">
      <button id="randGen" class="btn-ghost small">Generate Random</button>
      <div style="font-size:12px;color:var(--muted);padding-left:6px">Computer picks size 8–20</div>
    </div>

    <label>Controls</label>
    <div class="controls">
      <button id="btnInsertAll" class="btn-primary small">Insert All (step)</button>
      <button id="btnTraversal" class="small btn-ghost">Traversal ▶</button>
      <button id="btnStepF" class="small">Step ▶</button>
      <button id="btnStepB" class="small">◀ Step Back</button>
      <button id="btnReset" class="small">Reset</button>
      <button id="btnClear" class="small">Clear Tree</button>
    </div>

    <label>Operation / Search (uses same input above)</label>
    <div class="row">
      <button id="btnInsert" class="btn-primary small">Insert</button>
      <button id="btnSearch" class="small">Search</button>
    </div>

    <label>Animation speed</label>
    <div class="row">
      <input id="speed" type="range" min="50" max="1500" value="450" style="width:100%" />
    </div>

    <div style="margin-top:8px">
      <label>Legend</label>
      <div class="legend">
        <div class="badge"><div style="width:14px;height:14px;border-radius:6px;background:var(--pastel2)"></div><div class="smallText">Active (comparing)</div></div>
        <div class="badge"><div style="width:14px;height:14px;border-radius:6px;background:var(--pastel1)"></div><div class="smallText">Splitting</div></div>
        <div class="badge"><div style="width:14px;height:14px;border-radius:6px;background:var(--pastel3)"></div><div class="smallText">Final</div></div>
      </div>
    </div>

    <div style="margin-top:12px;">
      <label>Status</label>
      <div id="status" class="smallText">Ready.</div>
    </div>

    <div style="margin-top:8px;">
      <label>Current sequence</label>
      <div id="sequence" class="smallText" style="word-break:break-word">[]</div>
    </div>

  </div>

  <div class="vis panel">
    <h2 style="display:flex;justify-content:space-between;align-items:center">
      Visualization
      <div style="font-size:13px;color:var(--muted)">B-Tree view</div>
    </h2>
    <svg id="canvas" viewBox="0 0 1200 700" preserveAspectRatio="xMidYMin meet"></svg>
  </div>
</div>

<script>


(function(){
  function deepClone(obj){ return JSON.parse(JSON.stringify(obj)); }

  class BNode {
    constructor(leaf = true){
      this.keys = [];
      this.children = [];
      this.leaf = leaf;
      this.id = BNode._id++;
    }
  }
  BNode._id = 1;

  class BTree {
    constructor(t){
      this.t = t;
      this.root = new BNode(true);
      this.snapshots = [];
    }
    snapshot(desc, highlights = {}){
      try {
        const treeSer = this.serializeNode(this.root);
        this.snapshots.push({tree: treeSer, highlights, desc});
      } catch(e){
        console.error('snapshot error', e);
      }
    }
    serializeNode(node){
      return { id: node.id, keys: node.keys.slice(), leaf: node.leaf, children: node.children.map(c=>this.serializeNode(c)) };
    }

    searchPrint(val){
      this.snapshot(`Start search for ${val}`);
      const found = this._search(this.root, val);
      this.snapshot(found ? `Found ${val}` : `${val} not found`);
      return found;
    }
    _search(node, val){
      let i=0;
      while(i < node.keys.length && val > node.keys[i]){
        this.snapshot(`Comparing ${val} > ${node.keys[i]}`, {activeNode: node.id, activeKeyIndex: i});
        i++;
      }
      if(i < node.keys.length && val === node.keys[i]){
        this.snapshot(`Key ${val} equals node key`, {activeNode: node.id, activeKeyIndex: i, finalKey: {node: node.id, index: i}});
        return true;
      }
      if(node.leaf){
        this.snapshot(`Reached leaf: ${val} not present`, {activeNode: node.id});
        return false;
      } else {
        this.snapshot(`Descend to child ${i}`, {activeNode: node.id, childIndex: i});
        return this._search(node.children[i], val);
      }
    }

    insertPrint(k){
      this.snapshot(`Start insertion of ${k}`);
      const r = this.root;
      if(r.keys.length === 2*this.t -1){
        const s = new BNode(false);
        s.children.push(r);
        this.root = s;
        this.snapshot(`Root full — splitting root`, {activeNode: r.id, splitting: true});
        this._splitChild(s, 0);
        this.snapshot(`After root split`, {activeNode: s.id});
        this._insertNonFull(s, k);
      } else {
        this._insertNonFull(r, k);
      }
      this.snapshot(`Finished insertion of ${k}`);
    }

    _splitChild(parent, i){
      const t = this.t;
      const y = parent.children[i];
      const z = new BNode(y.leaf);
      z.keys = y.keys.slice(t);
      const mid = y.keys[t-1];
      y.keys = y.keys.slice(0, t-1);
      if(!y.leaf){
        z.children = y.children.slice(t);
        y.children = y.children.slice(0, t);
      }
      parent.children.splice(i+1, 0, z);
      parent.keys.splice(i, 0, mid);
      this.snapshot(`Split node ${y.id} at median ${mid} → create node ${z.id}`, {
        splitting: true, splitFrom: y.id, splitTo: z.id, promoted: {parent: parent.id, key: i}
      });
    }

    _insertNonFull(node, k){
      let i = node.keys.length - 1;
      if(node.leaf){
        while(i >=0 && k < node.keys[i]){
          this.snapshot(`Compare ${k} < ${node.keys[i]}`, {activeNode: node.id, activeKeyIndex: i});
          i--;
        }
        node.keys.splice(i+1, 0, k);
        this.snapshot(`Inserted ${k} into node ${node.id}`, {activeNode: node.id, finalKey: {node: node.id, index: i+1}});
      } else {
        while(i >=0 && k < node.keys[i]){
          this.snapshot(`Compare ${k} < ${node.keys[i]}`, {activeNode: node.id, activeKeyIndex: i});
          i--;
        }
        i++;
        this.snapshot(`Descend to child ${i} of node ${node.id}`, {activeNode: node.id, childIndex: i});
        if(node.children[i].keys.length === 2*this.t -1){
          this.snapshot(`Child ${node.children[i].id} full — will split`, {activeNode: node.id, childIndex: i, splitting:true});
          this._splitChild(node, i);
          if(k > node.keys[i]) {
            this.snapshot(`${k} > promoted key ${node.keys[i]}, move to child ${i+1}`, {activeNode: node.id, activeKeyIndex: i});
            i++;
          } else {
            this.snapshot(`${k} <= promoted key ${node.keys[i]}, move to child ${i}`, {activeNode: node.id, activeKeyIndex: i});
          }
        }
        this._insertNonFull(node.children[i], k);
      }
    }

    traversalPrint(){
      this.snapshot('Start in-order traversal');
      this._traverseNode(this.root);
      this.snapshot('Finished traversal');
    }
    _traverseNode(node){
      if(!node) return;
      for(let i=0;i<node.keys.length;i++){
        if(!node.leaf) this._traverseNode(node.children[i]);
        this.snapshot(`Visit key ${node.keys[i]} in node ${node.id}`, {activeNode: node.id, activeKeyIndex: i, finalKey: {node: node.id, index: i}});
      }
      if(!node.leaf) this._traverseNode(node.children[node.keys.length]);
    }
  }

  
  const svg = document.getElementById('canvas');
  const statusEl = document.getElementById('status');
  const seqEl = document.getElementById('sequence');

  const tSelect = document.getElementById('degree');
  const speedInput = document.getElementById('speed');
  const dataInput = document.getElementById('dataInput');
  const loadCustom = document.getElementById('loadCustom');
  const randGen = document.getElementById('randGen');
  const btnInsert = document.getElementById('btnInsert');
  const btnSearch = document.getElementById('btnSearch');
  const btnInsertAll = document.getElementById('btnInsertAll');
  const btnTraversal = document.getElementById('btnTraversal');
  const btnStepF = document.getElementById('btnStepF');
  const btnStepB = document.getElementById('btnStepB');
  const btnReset = document.getElementById('btnReset');
  const btnClear = document.getElementById('btnClear');

  let tree = new BTree(parseInt(tSelect.value));
  let sequence = [];
  let playing = false;
  let currentSnapshotIndex = 0;
  let playbackTimer = null;

  function setStatus(text){ statusEl.textContent = text; }
  function updateSequenceDisplay(){ seqEl.textContent = '[' + sequence.join(', ') + ']'; }
  function resetPlayback(){ currentSnapshotIndex = 0; playing = false; if(playbackTimer){ clearTimeout(playbackTimer); playbackTimer = null; } }

  function renderSnapshot(snapshot){
    while(svg.firstChild) svg.removeChild(svg.firstChild);
    const desc = snapshot.desc || '';
    const descText = document.createElementNS('http://www.w3.org/2000/svg','text');
    descText.setAttribute('x', 14);
    descText.setAttribute('y', 22);
    descText.setAttribute('class','smallText');
    descText.setAttribute('fill','#4b5563');
    descText.setAttribute('font-size','13');
    descText.textContent = desc;
    svg.appendChild(descText);

    function computeWidths(node){
      if(node.children.length === 0) { node._width = Math.max(80, node.keys.length * 68 + 20); return node._width; }
      else {
        let w = 0;
        for(const c of node.children) w += computeWidths(c) + 20;
        node._width = Math.max(node.keys.length * 68 + 20, w);
        return node._width;
      }
    }
    function assignPositions(node, x, y){
      node._x = x + node._width/2;
      node._y = y;
      if(node.children.length>0){
        let start = x;
        for(const c of node.children){
          assignPositions(c, start, y + 110);
          start += c._width + 20;
        }
      }
    }
    const map = new Map();
    function buildMap(node){ map.set(node.id, node); for(const c of node.children) buildMap(c); }

    if(snapshot.tree){
      buildMap(snapshot.tree);
      computeWidths(snapshot.tree);
      assignPositions(snapshot.tree, 40, 50);

      function drawLinks(node){
        for(const c of node.children){
          const x1 = node._x, y1 = node._y + 30, x2 = c._x, y2 = c._y - 6;
          const path = document.createElementNS('http://www.w3.org/2000/svg','path');
          const d = `M ${x1} ${y1} C ${x1} ${y1+30} ${x2} ${y2-30} ${x2} ${y2}`;
          path.setAttribute('d', d);
          path.setAttribute('stroke', 'rgba(30,40,50,0.08)');
          path.setAttribute('fill', 'none');
          path.setAttribute('stroke-width', '1.2');
          svg.appendChild(path);
          drawLinks(c);
        }
      }
      drawLinks(snapshot.tree);

      function drawNode(node){
        const keyCount = node.keys.length;
        const nodeW = Math.max(80, keyCount * 68 + 12);
        const nodeH = 36;
        const x = node._x - nodeW/2;
        const y = node._y;
        const g = document.createElementNS('http://www.w3.org/2000/svg','g');
        g.setAttribute('transform', `translate(${x},${y})`);
        const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
        rect.setAttribute('width', nodeW);
        rect.setAttribute('height', nodeH);
        rect.setAttribute('class','node');
        rect.setAttribute('rx',10);
        rect.setAttribute('fill', '#fff');
        svg.appendChild(g);
        g.appendChild(rect);

        const startX = 8;
        for(let i=0;i<keyCount;i++){
          const kx = startX + i*68;
          const keyRect = document.createElementNS('http://www.w3.org/2000/svg','rect');
          keyRect.setAttribute('x', kx);
          keyRect.setAttribute('y', 6);
          keyRect.setAttribute('width', 60);
          keyRect.setAttribute('height', 24);
          keyRect.setAttribute('rx',8);
          let fill = '#ffffff';
          const highlights = snapshot.highlights || {};
          if(highlights.finalKey && highlights.finalKey.node === node.id && highlights.finalKey.index === i){
            fill = getComputedStyle(document.documentElement).getPropertyValue('--pastel3');
          } else if(highlights.activeNode === node.id && highlights.activeKeyIndex === i){
            fill = getComputedStyle(document.documentElement).getPropertyValue('--pastel2');
          } else if(highlights.splitting && highlights.splitFrom === node.id){
            fill = getComputedStyle(document.documentElement).getPropertyValue('--pastel1');
          }
          keyRect.setAttribute('fill', fill);
          keyRect.setAttribute('stroke', 'rgba(20,30,40,0.06)');
          g.appendChild(keyRect);

          const txt = document.createElementNS('http://www.w3.org/2000/svg','text');
          txt.setAttribute('x', kx + 30);
          txt.setAttribute('y', 22);
          txt.setAttribute('text-anchor','middle');
          txt.setAttribute('class','keyText');
          txt.textContent = node.keys[i];
          g.appendChild(txt);
        }

        const label = document.createElementNS('http://www.w3.org/2000/svg','text');
        label.setAttribute('x', node._x);
        label.setAttribute('y', node._y + nodeH + 14);
        label.setAttribute('text-anchor','middle');
        label.setAttribute('class','smallText');
        label.textContent = `id:${node.id}`;
        svg.appendChild(label);

        for(const c of node.children) drawNode(c);
      }
      drawNode(snapshot.tree);
    } else {
      const t = document.createElementNS('http://www.w3.org/2000/svg','text');
      t.setAttribute('x', 80);
      t.setAttribute('y', 120);
      t.setAttribute('fill','#6b7280');
      t.setAttribute('font-size','16');
      t.textContent = 'Tree empty';
      svg.appendChild(t);
    }
    setStatus(snapshot.desc || '');
  }

  
  function playFrom(idx){
    if(idx < 0) idx = 0;
    if(idx >= tree.snapshots.length) { playing = false; setStatus('Reached end.'); return; }
    currentSnapshotIndex = idx;
    playing = true;
    const speed = parseInt(speedInput.value);
    function step(){
      if(!playing) return;
      const snap = tree.snapshots[currentSnapshotIndex];
      renderSnapshot(snap);
      currentSnapshotIndex++;
      if(currentSnapshotIndex >= tree.snapshots.length){
        playing = false;
        setStatus('Playback finished.');
        return;
      }
      playbackTimer = setTimeout(step, speed);
    }
    step();
  }
  function stepForward(){
    if(tree.snapshots.length === 0) return;
    if(currentSnapshotIndex >= tree.snapshots.length) currentSnapshotIndex = tree.snapshots.length-1;
    renderSnapshot(tree.snapshots[currentSnapshotIndex]);
    currentSnapshotIndex = Math.min(tree.snapshots.length, currentSnapshotIndex + 1);
  }
  function stepBack(){
    if(tree.snapshots.length === 0) return;
    currentSnapshotIndex = Math.max(0, currentSnapshotIndex - 1);
    renderSnapshot(tree.snapshots[currentSnapshotIndex]);
  }

  
  tSelect.addEventListener('change', ()=> {
    tree = new BTree(parseInt(tSelect.value));
    sequence = [];
    updateSequenceDisplay();
    tree.snapshot('New tree created (t=' + tSelect.value + ')');
    resetPlayback();
    renderSnapshot(tree.snapshots[tree.snapshots.length-1]);
    console.log('Changed degree to', tSelect.value);
  });

  loadCustom.addEventListener('click', ()=>{
    const raw = dataInput.value.trim();
    if(!raw){ setStatus('Enter numbers separated by commas or a single value.'); return; }
    if(raw.includes(',') || raw.includes(' ')){
      const tokens = raw.split(/[, ]+/).map(s=>s.trim()).filter(s=>s.length>0);
      const arr = tokens.map(s=>parseInt(s)).filter(n=>Number.isFinite(n));
      if(arr.length === 0){ setStatus('No valid numbers found.'); return; }
      sequence = arr.slice();
      updateSequenceDisplay();
      setStatus('Loaded custom sequence (' + sequence.length + ' numbers).');
      console.log('Loaded custom sequence length', sequence.length, sequence.slice(0,20));
    } else {
      const n = parseInt(raw);
      if(Number.isFinite(n)){
        sequence = [n];
        updateSequenceDisplay();
        setStatus('Loaded single value.');
        console.log('Loaded single value', n);
      } else {
        setStatus('Input not recognized as number(s).');
      }
    }
  });

  randGen.addEventListener('click', ()=>{
    const size = Math.floor(Math.random() * 13) + 8; // 8..20
    const arr = [];
    for(let i=0;i<size;i++) arr.push(Math.floor(Math.random()*1000));
    sequence = arr;
    updateSequenceDisplay();
    setStatus('Generated ' + size + ' random numbers automatically.');
    console.log('Generated sequence length:', size, arr.slice(0,20));
  });

  btnInsert.addEventListener('click', ()=>{
    const raw = dataInput.value.trim();
    if(!raw){ setStatus('Enter a number in the input to insert.'); return; }
    const n = parseInt(raw);
    if(!Number.isFinite(n)){ setStatus('Enter a valid number to insert.'); return; }
    console.log('Inserting single value:', n);
    tree.insertPrint(n);
    resetPlayback();
    
    if(tree.snapshots.length>0) renderSnapshot(tree.snapshots[tree.snapshots.length-1]);
    setStatus('Inserted ' + n);
  });

  btnSearch.addEventListener('click', ()=>{
    const raw = dataInput.value.trim();
    if(!raw){ setStatus('Enter a number in the input to search.'); return; }
    const n = parseInt(raw);
    if(!Number.isFinite(n)){ setStatus('Enter a valid number to search.'); return; }
    console.log('Searching for:', n);
    tree.searchPrint(n);
    resetPlayback();
    if(tree.snapshots.length>0) renderSnapshot(tree.snapshots[tree.snapshots.length-1]);
  });

  btnInsertAll.addEventListener('click', ()=>{
    if(sequence.length === 0){ setStatus('Sequence empty. Load random or custom sequence.'); return; }
    console.log('Insert All: inserting sequence length', sequence.length);
    setStatus('Inserting sequence step by step...');
    for(const v of sequence){
      tree.insertPrint(v);
    }
    resetPlayback();
    
    if(tree.snapshots.length>0){
      renderSnapshot(tree.snapshots[tree.snapshots.length-1]);
      setStatus('Insertions completed; final tree rendered.');
      console.log('Finished Insert All. snapshots:', tree.snapshots.length);
    } else {
      setStatus('No snapshots recorded (unexpected).');
      console.warn('No snapshots after insert all');
    }
  });

  btnTraversal.addEventListener('click', ()=>{
    if(!tree.root || (tree.root.keys.length === 0 && tree.root.children.length === 0)){ setStatus('Tree empty.'); return; }
    console.log('Starting traversal');
    tree.traversalPrint();
    resetPlayback();
    const idx = tree.snapshots.findIndex(s=>s.desc && s.desc.startsWith('Start in-order traversal'));
    if(idx >= 0) playFrom(idx);
    else playFrom(0);
  });

  btnStepF.addEventListener('click', ()=>{
    playing = false;
    if(playbackTimer){ clearTimeout(playbackTimer); playbackTimer = null; }
    stepForward();
  });
  btnStepB.addEventListener('click', ()=>{
    playing = false;
    if(playbackTimer){ clearTimeout(playbackTimer); playbackTimer = null; }
    stepBack();
  });

  btnReset.addEventListener('click', ()=>{
    resetPlayback();
    tree.snapshots = [];
    tree.snapshot('Cleared snapshots (you can re-run operations).');
    renderSnapshot(tree.snapshots[0]);
    setStatus('Snapshots reset.');
    console.log('Snapshots reset');
  });

  btnClear.addEventListener('click', ()=>{
    tree = new BTree(parseInt(tSelect.value));
    sequence = [];
    updateSequenceDisplay();
    tree.snapshot('Cleared tree.');
    resetPlayback();
    renderSnapshot(tree.snapshots[0]);
    setStatus('Tree cleared.');
    console.log('Tree cleared');
  });

  dataInput.addEventListener('keydown', (e)=>{
    if(e.key === 'Enter') btnInsert.click();
  });

  
  tree.snapshot('New tree ready (t=' + tSelect.value + ')');
  renderSnapshot(tree.snapshots[0]);

  
  function fitViewBox(){
    const rect = svg.getBoundingClientRect();
    svg.setAttribute('viewBox', `0 0 ${Math.max(900, rect.width)} 700`);
  }
  window.addEventListener('resize', fitViewBox);
  fitViewBox();

  console.log('B-Tree visualizer initialized (open console for debug messages).');

})();
</script>
</body>
</html>