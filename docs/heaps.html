<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Heap Visualizer â€” MinHeap / MaxHeap</title>
<style>
  :root{
    --bg:#f6fbff; --card:#ffffff; --muted:#6b7280;
    --accent1:#dff7ef; --accent2:#f6e8fb; --accent3:#e8f0ff;
    --node:#fff; --stroke:#7aa7ff;
  }
  *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,-apple-system,'Segoe UI',Roboto}
  body{margin:14px;background:linear-gradient(180deg,var(--bg),#fbfcff);color:#07203a}
  .app{max-width:1200px;margin:0 auto;display:grid;grid-template-columns:1fr 340px;gap:16px;align-items:start}
  header{grid-column:1/-1;display:flex;align-items:center;gap:12px}
  h1{margin:0;font-size:20px}
  .card{background:var(--card);padding:12px;border-radius:12px;box-shadow:0 8px 22px rgba(20,30,80,0.06)}
  .controls{display:flex;flex-direction:column;gap:10px}
  label{font-size:13px;color:var(--muted)}
  select,input{padding:8px;border-radius:8px;border:1px solid #e6eefc;background:var(--card)}
  button{padding:8px 12px;border-radius:10px;border:0;background:linear-gradient(180deg,#7dd3fc,#60a5fa);color:white;cursor:pointer}
  button.ghost{background:transparent;border:1px solid #e6eefc;color:#184e77}
  .viz{height:520px;border-radius:12px;padding:12px;overflow:auto;background:linear-gradient(180deg,var(--accent3),#fff);position:relative}
  svg{width:100%;height:100%}
  .pseudocode{font-family:ui-monospace,Menlo,monospace;background:linear-gradient(180deg,#fff,#fbfdff);padding:10px;border-radius:8px;min-height:200px;overflow:auto;border:1px solid rgba(10,20,60,0.03)}
  .code-line{padding:4px 6px;border-radius:4px}
  .code-line.active{background:linear-gradient(90deg,var(--accent2),var(--accent3));color:#023047}
  .node-rect{fill:#fff;stroke:var(--stroke);stroke-width:2;rx:8;filter:drop-shadow(0 8px 18px rgba(20,40,80,0.06))}
  .node-text{font-weight:700;fill:#073b66}
  .highlight{stroke:#ffb86b;stroke-width:3}
  .arrayRow{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:10px}
  .slot{background:#fff;padding:6px 10px;border-radius:8px;border:1px solid #e6eefc;min-width:36px;text-align:center}
  .slot.highlight{background:#fff3d9}
  .footer{grid-column:1/-1;text-align:center;color:var(--muted);font-size:12px;margin-top:6px}
  @media(max-width:960px){.app{grid-template-columns:1fr}.viz{height:420px}}
</style>
</head>
<body>
<div class="app">
  <header>
    <div>
      <h1>Heap Visualizer: MinHeap / MaxHeap</h1>
    </div>
  </header>

  <main class="card">
    <div class="controls">
      <div style="display:flex;gap:8px;align-items:center">
        <label style="min-width:84px">Mode</label>
        <select id="modeSelect"><option value="min">Min-Heap</option><option value="max">Max-Heap</option></select>
        <label style="min-width:60px;margin-left:12px">Seed</label>
        <input id="seedLen" type="number" min="1" max="20" value="8" style="width:80px">
        <button id="randomBtn">Randomize</button>
        <button id="clearBtn" class="ghost">Clear</button>
      </div>

      <div style="display:flex;gap:8px;align-items:center">
        <label style="min-width:84px">Value</label>
        <input id="valInput" type="number" placeholder="number" style="width:120px">
        <button id="insertBtn">Insert</button>
        <button id="deleteBtn" class="ghost">Delete (value)</button>
        <button id="popBtn" class="ghost">Pop root</button>
      </div>

      <div style="display:flex;gap:8px;align-items:center">
        <label style="min-width:84px">Speed</label>
        <input id="speedRange" type="range" min="80" max="800" value="240">
        <div style="font-size:13px;color:var(--muted)"><span id="speedVal">240</span> ms</div>
      </div>

      <div style="display:flex;gap:8px;align-items:center">
        <label style="min-width:84px">Animate</label>
        <button id="playInsert" class="ghost">Animate last insert</button>
        <button id="playDelete" class="ghost">Animate last delete</button>
      </div>

      <div style="color:var(--muted);font-size:13px">Click Insert to add immediately. Use Animate buttons to replay the most recent operation step-by-step.</div>
    </div>

    <div style="height:10px"></div>

    <div class="viz" id="viz">
      <svg id="svg" viewBox="0 0 1000 520" preserveAspectRatio="xMidYMin meet"></svg>
      <div style="position:absolute;left:16px;right:16px;bottom:12px">
        <div style="font-size:13px;color:var(--muted)">Array representation</div>
        <div id="arrayRow" class="arrayRow"></div>
      </div>
    </div>
  </main>

  <aside class="card">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px"><strong>Pseudocode</strong><div style="font-size:12px;color:var(--muted)">Highlighted during animation</div></div>
    <div class="pseudocode" id="pseudocode"></div>
    <div style="margin-top:12px"><strong>Operation Log</strong><div id="log" style="height:160px;overflow:auto;margin-top:6px;color:var(--muted)"></div></div>
  </aside>

</div>

<script>

class Heap {
  constructor(type='min'){ this.type=type; this.data=[]; this.lastOpSteps=[]; this._snapshot=null }
  cmp(a,b){ return this.type==='min' ? a<b : a>b }

  buildFromArray(arr){ this.data = arr.slice();
    for(let i=Math.floor(this.data.length/2)-1;i>=0;i--) this.sink(i,false);
    this.lastOpSteps = []; this._snapshot = this.data.slice();
  }

  insert(val){
    this._snapshot = this.data.slice();
    const steps=[];
    this.data.push(val); const i=this.data.length-1; steps.push({type:'push',i,val});
    let cur=i;
    while(cur>0){ const p=Math.floor((cur-1)/2); steps.push({type:'compare',i:cur,p}); if(this.cmp(this.data[cur],this.data[p])){ steps.push({type:'swap',i:cur,j:p}); [this.data[cur],this.data[p]]=[this.data[p],this.data[cur]]; cur=p; } else break }
    this.lastOpSteps = steps; return steps }

  pop(){ this._snapshot = this.data.slice(); const steps=[]; if(this.data.length===0){ this.lastOpSteps = steps; return null }
    const root=this.data[0]; const last=this.data.pop(); steps.push({type:'pop',root}); if(this.data.length>0){ this.data[0]=last; steps.push({type:'setroot',val:last}); this.sink(0,true,steps) }
    this.lastOpSteps = steps; return root }

  deleteValue(val){
    this._snapshot = this.data.slice(); const idx=this.data.indexOf(val); if(idx===-1){ this.lastOpSteps=[]; return null }
    const steps=[];
    const last=this.data.pop();
    
    if(idx===this.data.length){
      steps.push({type:'delete-last',idx, val});
      this.lastOpSteps = steps; return val;
    }
    
    steps.push({type:'set',idx,val:last}); this.data[idx]=last;
    
    let cur=idx; let p=Math.floor((cur-1)/2);
    if(cur>0 && this.cmp(this.data[cur],this.data[p])){
      while(cur>0){ p=Math.floor((cur-1)/2); steps.push({type:'compare',i:cur,p}); if(this.cmp(this.data[cur],this.data[p])){ steps.push({type:'swap',i:cur,j:p}); [this.data[cur],this.data[p]]=[this.data[p],this.data[cur]]; cur=p; } else break }
    } else {
      this.sink(cur,true,steps);
    }
    
    steps.push({type:'remove-last',val:last});
    this.lastOpSteps = steps; return val }

  sink(i,record=true,stepsRef){ const steps = stepsRef||[]; const n=this.data.length; while(true){ let l=2*i+1, r=2*i+2, best=i; if(l<n && this.cmp(this.data[l],this.data[best])) best=l; if(r<n && this.cmp(this.data[r],this.data[best])) best=r; if(best!==i){ if(record) steps.push({type:'compare',i,best}); steps.push({type:'swap',i,j:best}); [this.data[i],this.data[best]]=[this.data[best],this.data[i]]; i=best; } else { if(record){ if(l<n) steps.push({type:'compare',i,l}); if(r<n) steps.push({type:'compare',i,r}); } break } } return steps }
}

const svg = document.getElementById('svg');
const arrayRow = document.getElementById('arrayRow');
const modeSel = document.getElementById('modeSelect');
const randomBtn = document.getElementById('randomBtn');
const clearBtn = document.getElementById('clearBtn');
const insertBtn = document.getElementById('insertBtn');
const deleteBtn = document.getElementById('deleteBtn');
const popBtn = document.getElementById('popBtn');
const valInput = document.getElementById('valInput');
const speedRange = document.getElementById('speedRange');
const speedVal = document.getElementById('speedVal');
const pseudocode = document.getElementById('pseudocode');
const logEl = document.getElementById('log');
const playInsert = document.getElementById('playInsert');
const playDelete = document.getElementById('playDelete');

let heap = new Heap(modeSel.value);
let animInterval = null;
let replaySteps = [];

function log(msg){ const d=document.createElement('div'); d.textContent=msg; logEl.prepend(d) }

function genRandom(len){ const a=[]; for(let i=0;i<len;i++) a.push(Math.floor(Math.random()*90)+1); return a }

function render(){ svg.innerHTML=''; arrayRow.innerHTML=''; const data = heap.data;
  
  const positions = {};
  for(let i=0;i<data.length;i++){
    const level = Math.floor(Math.log2(i+1));
    const indexInLevel = i - (2**level -1);
    const nodesInLevel = 2**level;
    const gap = 1000 / (nodesInLevel+1);
    const x = gap*(indexInLevel+1);
    const y = 40 + level*90;
    positions[i]={x,y};
  }
  
  for(let i=0;i<data.length;i++){
    const left = 2*i+1, right=2*i+2;
    if(left<data.length){ drawEdge(positions[i],positions[left]) }
    if(right<data.length){ drawEdge(positions[i],positions[right]) }
  }
 
  for(let i=0;i<data.length;i++) drawNode(positions[i].x,positions[i].y,data[i],i);
  
  for(let i=0;i<data.length;i++){ const s=document.createElement('div'); s.className='slot'; s.textContent=data[i]; s.dataset.idx=i; arrayRow.appendChild(s) }
}

function drawEdge(p1,p2){ const path = document.createElementNS('http://www.w3.org/2000/svg','path'); const d=`M ${p1.x} ${p1.y+18} C ${p1.x} ${p1.y+50} ${p2.x} ${p2.y-30} ${p2.x} ${p2.y-6}`; path.setAttribute('d',d); path.setAttribute('stroke','#c8dbff'); path.setAttribute('fill','none'); path.setAttribute('stroke-width','2'); svg.appendChild(path) }

function drawNode(x,y,val,idx){ const g=document.createElementNS('http://www.w3.org/2000/svg','g'); g.setAttribute('transform',`translate(${x-22},${y-14})`); g.dataset.idx=idx; const r=document.createElementNS('http://www.w3.org/2000/svg','rect'); r.setAttribute('width',44); r.setAttribute('height',28); r.setAttribute('rx',8); r.setAttribute('class','node-rect'); r.dataset.idx=idx; const t=document.createElementNS('http://www.w3.org/2000/svg','text'); t.setAttribute('x',22); t.setAttribute('y',18); t.setAttribute('text-anchor','middle'); t.setAttribute('class','node-text'); t.textContent=val; g.appendChild(r); g.appendChild(t); svg.appendChild(g); }


const templates = {
  'insert': ['append to array', 'bubble-up: compare with parent', 'swap while heap property violated'],
  'pop': ['replace root with last element', 'sink-down: compare children', 'swap with appropriate child until heap property holds'],
  'delete': ['find index', 'replace with last', 'bubble-up or sink-down to restore heap']
}
function showPseudocode(k){ pseudocode.innerHTML=''; const lines=templates[k]||['--']; lines.forEach((l,i)=>{ const d=document.createElement('div'); d.className='code-line'; d.textContent=l; d.dataset.idx=i; pseudocode.appendChild(d) }) }


function playSteps(steps, replay=false){ if(!steps || steps.length===0) return; if(animInterval) clearInterval(animInterval); clearHighlights(); const speed = parseInt(speedRange.value,10); let i=0; replaySteps = steps.slice(); log('Play animation with '+steps.length+' steps'); animInterval=setInterval(()=>{
    if(i>=replaySteps.length){ clearInterval(animInterval); animInterval=null; return }
    const s=replaySteps[i]; runStepVisual(s, replay); i++;
  }, speed);
}

function runStepVisual(s, replay){
  clearHighlights(); if(s.type==='push'){
    if(replay){ heap.data.push(s.val); render() }
    highlightIndex(s.i); showPseudocode('insert');
  } else if(s.type==='compare'){
    highlightIndex(s.i); highlightIndex(s.p||s.l||s.r||s.j); showPseudocode('insert');
  } else if(s.type==='swap'){
    const i = s.i, j = s.j;
    if(replay){ [heap.data[i], heap.data[j]] = [heap.data[j], heap.data[i]]; render() }
    highlightIndex(i); highlightIndex(j);
    showPseudocode('insert');
  } else if(s.type==='pop'){
    if(replay){
      
    }
    showPseudocode('pop'); log('popped root '+s.root);
  } else if(s.type==='setroot'){
    if(replay){ heap.data[0]=s.val; render() }
    showPseudocode('pop');
  } else if(s.type==='delete-last'){
    if(replay){
      heap.data.splice(s.idx,1);
      render();
    }
    showPseudocode('delete'); log('deleted '+s.val);
  } else if(s.type==='remove-last'){
    if(replay){ heap.data.pop(); render() }
    showPseudocode('delete'); log('removed last '+s.val);
  } else if(s.type==='set'){
    if(replay){ heap.data[s.idx]=s.val; render() }
    showPseudocode('delete');
  }
}

function clearHighlights(){ const rects = svg.querySelectorAll('rect'); rects.forEach(r=>r.classList.remove('highlight')); const slots = arrayRow.querySelectorAll('.slot'); slots.forEach(s=>s.classList.remove('highlight')) }
function highlightIndex(idx){ const rect = svg.querySelector(`rect[data-idx="${idx}"]`); if(rect) rect.classList.add('highlight'); const slot = arrayRow.querySelector(`[data-idx="${idx}"]`); if(slot) slot.classList.add('highlight'); }

randomBtn.addEventListener('click', ()=>{ const arr=genRandom(parseInt(seedLen.value,10)||8); heap = new Heap(modeSel.value); heap.buildFromArray(arr); render(); showPseudocode('insert'); log('Built heap: '+arr.join(', ')) })
clearBtn.addEventListener('click', ()=>{ heap = new Heap(modeSel.value); render(); showPseudocode('insert'); log('Cleared heap') })

insertBtn.addEventListener('click', ()=>{ const v=Number(valInput.value); if(Number.isNaN(v)) return; const steps = heap.insert(v); render(); playSteps(steps); log('Inserted '+v); })

popBtn.addEventListener('click', ()=>{ const root = heap.pop(); render(); playSteps(heap.lastOpSteps); log('Popped '+root); })

deleteBtn.addEventListener('click', ()=>{ const v=Number(valInput.value); if(Number.isNaN(v)) return; const steps = heap.deleteValue(v); render(); if(steps && steps.length) playSteps(heap.lastOpSteps); log('Delete requested '+v); })

playInsert.addEventListener('click', ()=>{
  if(!heap.lastOpSteps || heap.lastOpSteps.length===0){ log('No operation to replay'); return }
  if(!heap._snapshot){ log('No snapshot available for replay'); return }
  heap.data = heap._snapshot.slice(); render(); playSteps(heap.lastOpSteps, true);
})
playDelete.addEventListener('click', ()=>{
  if(!heap.lastOpSteps || heap.lastOpSteps.length===0){ log('No operation to replay'); return }
  if(!heap._snapshot){ log('No snapshot available for replay'); return }
  heap.data = heap._snapshot.slice(); render(); playSteps(heap.lastOpSteps, true);
})

modeSel.addEventListener('change', ()=>{ heap = new Heap(modeSel.value); render(); log('Switched to '+modeSel.value) })
speedRange.addEventListener('input', ()=>{ speedVal.textContent = speedRange.value; if(animInterval){ clearInterval(animInterval); animInterval=null } })

showPseudocode('insert'); render();
</script>
</body>
</html>


