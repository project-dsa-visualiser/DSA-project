<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Tree Visualizer â€” Binary / BST / AVL</title>
    <style>
        :root {
            --bg: #f7fbff;
            --card: #ffffff;
            --muted: #6b7280;
            --accent-a: #e6f7f2;
            --accent-b: #f6e7fb;
            --accent-c: #e9f3ff;
            --node-bg: #fff;
            --border: #dfe8ff;
        }

        * {
            box-sizing: border-box;
            font-family: Inter, system-ui, Segoe UI, Roboto, Arial
        }

        body {
            margin: 16px;
            background: linear-gradient(180deg, var(--bg), #fbfcff);
            color: #0b2447
        }

        .app {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 380px;
            gap: 16px;
            align-items: start
        }

        header {
            grid-column: 1/-1;
            display: flex;
            align-items: center;
            gap: 12px
        }

        h1 {
            font-size: 20px;
            margin: 0
        }

        .card {
            background: var(--card);
            padding: 14px;
            border-radius: 12px;
            box-shadow: 0 8px 28px rgba(9, 20, 50, 0.06)
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px
        }

        label {
            font-size: 13px;
            color: var(--muted)
        }

        select,
        input {
            padding: 8px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: var(--card)
        }

        button {
            padding: 8px 12px;
            border-radius: 10px;
            border: 0;
            background: linear-gradient(180deg, #8ec5ff, #7aa7ff);
            color: white;
            cursor: pointer
        }

        button.ghost {
            background: transparent;
            border: 1px solid #e6eefc;
            color: #184e77
        }

        .viz {
            height: 560px;
            border-radius: 12px;
            padding: 12px;
            overflow: auto;
            background: linear-gradient(180deg, var(--accent-c), #fbfdff);
            position: relative
        }

        svg {
            width: 100%;
            height: 100%
        }

        .controls-row {
            display: flex;
            gap: 8px;
            align-items: center
        }

        .pseudocode {
            font-family: ui-monospace, Menlo, monospace;
            background: linear-gradient(180deg, #fff, #fbfdff);
            padding: 10px;
            border-radius: 8px;
            min-height: 160px;
            overflow: auto;
            border: 1px solid rgba(10, 20, 60, 0.03)
        }

        .code-line {
            padding: 4px 6px;
            border-radius: 4px
        }

        .code-line.active {
            background: linear-gradient(90deg, var(--accent-b), var(--accent-c));
            color: #023047
        }

        .node-g {
            cursor: default
        }

        .node-rect {
            fill: #fff;
            stroke: #7aa7ff;
            stroke-width: 2;
            filter: drop-shadow(0 6px 12px rgba(22, 40, 100, 0.06))
        }

        .node-text {
            font-weight: 700;
            fill: #07203a
        }

        .node-small {
            font-size: 11px;
            fill: #184e77
        }

        .highlight {
            stroke: #ffb86b;
            stroke-width: 3
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px
        }

        .footer {
            grid-column: 1/-1;
            text-align: center;
            color: var(--muted);
            font-size: 12px;
            margin-top: 6px
        }

        @media(max-width:980px) {
            .app {
                grid-template-columns: 1fr
            }

            .viz {
                height: 420px
            }
        }
    </style>
</head>

<body>
    <div class="app">
        <header>
            <div>
                <h1>Tree Visualizer: Binary Tree, BST, AVL</h1>
                <div style="color:var(--muted);font-size:13px">Insert / Delete, Traversals with animation, Pseudocode
                </div>
            </div>
        </header>

        <div class="card">
            <div class="controls">
                <div class="controls-row">
                    <label style="min-width:80px">Tree type</label>
                    <select id="treeType">
                        <option value="binary">Binary Tree (level-insert)</option>
                        <option value="bst">Binary Search Tree</option>
                        <option value="avl">AVL Tree (self-balancing)</option>
                    </select>
                </div>

                <div class="controls-row">
                    <label style="min-width:80px">Seed length</label>
                    <input id="seedLen" type="number" min="1" max="20" value="7" style="width:100px">
                    <button id="randomBtn">Randomize & Build</button>
                    <button id="clearBtn" class="ghost">Clear</button>
                </div>

                <div class="controls-row">
                    <label style="min-width:80px">Value</label>
                    <input id="customVal" type="number" placeholder="value" style="width:120px">
                    <button id="insertBtn">Insert</button>
                    <button id="deleteBtn" class="ghost">Delete</button>
                </div>

                <div style="display:flex;gap:10px;align-items:center">
                    <label style="min-width:80px">Traversal</label>
                    <select id="travType">
                        <option value="inorder">Inorder</option>
                        <option value="preorder">Preorder</option>
                        <option value="postorder">Postorder</option>
                    </select>
                    <button id="travBtn">Animate</button>
                </div>

                <div class="controls-row">
                    <label style="min-width:80px">Speed</label>
                    <input id="speedRange" type="range" min="150" max="1200" value="600">
                    <div style="font-size:13px;color:var(--muted)"><span id="speedVal">600</span> ms</div>
                </div>

                <div style="margin-top:6px;color:var(--muted);font-size:13px">Binary Tree uses level-order
                    insertion (fills left to right). BST/AVL follow ordering rules. AVL will rotate automatically on
                    insert/delete.</div>
            </div>

            <div style="height:16px"></div>

            <div class="viz" id="vizArea">
                <svg id="svgRoot" viewBox="0 0 1200 520" preserveAspectRatio="xMidYMin meet"></svg>
            </div>
        </div>

        <aside class="card">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
                <strong>Pseudocode</strong>
                <div style="font-size:12px;color:var(--muted)">Highlighted during operations</div>
            </div>
            <div class="pseudocode" id="pseudocode"></div>
            <div style="margin-top:12px"><strong>Operation Log</strong>
                <div id="oplog" style="height:180px;overflow:auto;margin-top:6px;color:var(--muted)"></div>
            </div>
        </aside>
    </div>

    <script>
        
        class BTNode { constructor(v) { this.val = v; this.left = null; this.right = null; this.h = 1; this._id = BTNode._next++ } }
        BTNode._next = 1;

        class BinaryTree {
            constructor() { this.root = null }
            buildFromArray(arr) { this.root = null; for (const v of arr) this.insertLevel(v) }
            insertLevel(val) {
                const node = new BTNode(val); if (!this.root) { this.root = node; return node }
                const q = [this.root]; while (q.length) { const n = q.shift(); if (!n.left) { n.left = node; return node } else q.push(n.left); if (!n.right) { n.right = node; return node } else q.push(n.right) }
            }
            delete(val) {
                if (!this.root) return null; let toRemove = null, deep = null; const q = [this.root]; while (q.length) { const n = q.shift(); if (n.val === val && !toRemove) toRemove = n; if (n.left) q.push(n.left); if (n.right) q.push(n.right); deep = n }
                if (!toRemove) return null; toRemove.val = deep.val;
                const qq = [this.root]; while (qq.length) { const n = qq.shift(); if (n.left === deep) { n.left = null; break } if (n.right === deep) { n.right = null; break } if (n.left) qq.push(n.left); if (n.right) qq.push(n.right) }
                return deep;
            }
        }

        class BST {
            constructor() { this.root = null }
            insert(val) { this.root = this._insert(this.root, val); return this._lastInserted }
            _insert(node, val) { if (!node) { const n = new BTNode(val); this._lastInserted = n; return n } if (val < node.val) node.left = this._insert(node.left, val); else node.right = this._insert(node.right, val); return node }
            delete(val) { this.root = this._delete(this.root, val) }
            _delete(node, val) { if (!node) return null; if (val < node.val) node.left = this._delete(node.left, val); else if (val > node.val) node.right = this._delete(node.right, val); else { if (!node.left) return node.right; if (!node.right) return node.left; let succ = node.right; while (succ.left) succ = succ.left; node.val = succ.val; node.right = this._delete(node.right, succ.val); } return node }
        }

        class AVL extends BST {
            constructor() { super() }
            _height(n) { return n ? n.h : 0 }
            _update(n) { n.h = 1 + Math.max(this._height(n.left), this._height(n.right)); }
            _balance(n) { return n ? this._height(n.left) - this._height(n.right) : 0 }
            _rotateRight(y) { const x = y.left; const T2 = x.right; x.right = y; y.left = T2; this._update(y); this._update(x); return x }
            _rotateLeft(x) { const y = x.right; const T2 = y.left; y.left = x; x.right = T2; this._update(x); this._update(y); return y }
            _insert(node, val) {
                if (!node) { const n = new BTNode(val); this._lastInserted = n; return n } if (val < node.val) node.left = this._insert(node.left, val); else node.right = this._insert(node.right, val);
                this._update(node); const balance = this._balance(node);
                if (balance > 1 && val < node.left.val) return this._rotateRight(node);
                if (balance < -1 && val > node.right.val) return this._rotateLeft(node);
                if (balance > 1 && val > node.left.val) { node.left = this._rotateLeft(node.left); return this._rotateRight(node) }
                if (balance < -1 && val < node.right.val) { node.right = this._rotateRight(node.right); return this._rotateLeft(node) }
                return node
            }
            insert(val) { this.root = this._insert(this.root, val); return this._lastInserted }
            _delete(node, val) {
                if (!node) return null; if (val < node.val) node.left = this._delete(node.left, val); else if (val > node.val) node.right = this._delete(node.right, val); else { if (!node.left) return node.right; if (!node.right) return node.left; let succ = node.right; while (succ.left) succ = succ.left; node.val = succ.val; node.right = this._delete(node.right, succ.val); }
                this._update(node); const balance = this._balance(node);
                if (balance > 1 && this._balance(node.left) >= 0) return this._rotateRight(node);
                if (balance > 1 && this._balance(node.left) < 0) { node.left = this._rotateLeft(node.left); return this._rotateRight(node) }
                if (balance < -1 && this._balance(node.right) <= 0) return this._rotateLeft(node);
                if (balance < -1 && this._balance(node.right) > 0) { node.right = this._rotateRight(node.right); return this._rotateLeft(node) }
                return node
            }
            delete(val) { this.root = this._delete(this.root, val) }
        }

        const treeTypeSel = document.getElementById('treeType');
        const randomBtn = document.getElementById('randomBtn');
        const clearBtn = document.getElementById('clearBtn');
        const insertBtn = document.getElementById('insertBtn');
        const deleteBtn = document.getElementById('deleteBtn');
        const travBtn = document.getElementById('travBtn');
        const travType = document.getElementById('travType');
        const seedLen = document.getElementById('seedLen');
        const customVal = document.getElementById('customVal');
        const speedRange = document.getElementById('speedRange');
        const speedVal = document.getElementById('speedVal');
        const pseudocodeEl = document.getElementById('pseudocode');
        const svgRoot = document.getElementById('svgRoot');
        const oplog = document.getElementById('oplog');
        let engine = new BinaryTree();
        let nodeToG = new Map();
        let animTimer = null;

        function logOp(s) { const d = document.createElement('div'); d.textContent = s; oplog.prepend(d) }

        function makeEngine(type) { if (type === 'binary') return new BinaryTree(); if (type === 'bst') return new BST(); return new AVL() }
        function genRandomArray(len) { const a = []; for (let i = 0; i < len; i++) a.push(Math.floor(Math.random() * 90) + 1); return a }

        function buildFromArray(arr) { engine = makeEngine(treeTypeSel.value); nodeToG.clear(); BTNode._next = 1; for (const v of arr) { if (engine.insert) engine.insert(v); else engine.insertLevel(v) } render(); }

        function computePositions(root) {
            const positions = []; function dfs(n, x, y, gap) { if (!n) return; positions.push({ n, x, y }); dfs(n.left, x - gap, y + 90, gap / 1.9); dfs(n.right, x + gap, y + 90, gap / 1.9); }
            dfs(root, 600, 40, 300); return positions
        }

        function render() {
            svgRoot.innerHTML = ''; nodeToG.clear(); if (!engine.root) { const t = document.createElementNS('http://www.w3.org/2000/svg', 'text'); t.setAttribute('x', 600); t.setAttribute('y', 240); t.setAttribute('text-anchor', 'middle'); t.setAttribute('fill', '#6b7280'); t.setAttribute('font-size', 18); t.textContent = '(empty tree)'; svgRoot.appendChild(t); return }
            const positions = computePositions(engine.root);
            
            for (const p of positions) { if (p.n.left) { const c = positions.find(x => x.n === p.n.left); drawLink(p.x, p.y, c.x, c.y) } if (p.n.right) { const c = positions.find(x => x.n === p.n.right); drawLink(p.x, p.y, c.x, c.y) } }
            
            for (const p of positions) drawNode(p.n, p.x, p.y);
        }

        function drawLink(x1, y1, x2, y2) { const path = document.createElementNS('http://www.w3.org/2000/svg', 'path'); const d = `M ${x1} ${y1 + 18} C ${x1} ${y1 + 18 + 30} ${x2} ${y2 - 30} ${x2} ${y2 - 6}`; path.setAttribute('d', d); path.setAttribute('stroke', '#9fb7ff'); path.setAttribute('fill', 'none'); path.setAttribute('stroke-width', '2'); svgRoot.appendChild(path) }

        function drawNode(node, x, y) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g'); g.setAttribute('transform', `translate(${x - 28},${y - 14})`); g.setAttribute('class', 'node-g'); g.dataset.id = node._id;
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect'); rect.setAttribute('width', 56); rect.setAttribute('height', 28); rect.setAttribute('rx', 8); rect.setAttribute('class', 'node-rect'); rect.dataset.id = node._id;
            const txt = document.createElementNS('http://www.w3.org/2000/svg', 'text'); txt.setAttribute('x', 28); txt.setAttribute('y', 18); txt.setAttribute('text-anchor', 'middle'); txt.setAttribute('class', 'node-text'); txt.textContent = node.val;
            g.appendChild(rect); g.appendChild(txt);
            if (node.h !== undefined) { const hb = document.createElementNS('http://www.w3.org/2000/svg', 'text'); hb.setAttribute('x', 48); hb.setAttribute('y', 10); hb.setAttribute('class', 'node-small'); hb.textContent = node.h; g.appendChild(hb) }
            svgRoot.appendChild(g);
            nodeToG.set(node._id, g);
        }

        function inorderArr() { const a = []; (function dfs(n) { if (!n) return; dfs(n.left); a.push(n); dfs(n.right) })(engine.root); return a }
        function preorderArr() { const a = []; (function dfs(n) { if (!n) return; a.push(n); dfs(n.left); dfs(n.right) })(engine.root); return a }
        function postorderArr() { const a = []; (function dfs(n) { if (!n) return; dfs(n.left); dfs(n.right); a.push(n) })(engine.root); return a }

        function clearHighlights() { const hs = svgRoot.querySelectorAll('rect.highlight'); hs.forEach(r => r.classList.remove('highlight')) }

        function highlightSequence(nodes, label) {
            if (animTimer) { clearInterval(animTimer); animTimer = null } clearHighlights(); const speed = parseInt(speedRange.value, 10); showPseudocode('traversal'); logOp(`Start traversal: ${label}`);
            let i = 0; animTimer = setInterval(() => {
                clearHighlights(); if (i >= nodes.length) { clearInterval(animTimer); animTimer = null; logOp('Traversal finished'); return }
                const node = nodes[i]; const g = nodeToG.get(node._id); if (g) {
                    const r = g.querySelector('rect.node-rect'); if (r) r.classList.add('highlight');
                    
                }
                i++;
            }, speed);
        }

        const templates = {
            'binary-insert': ['create node', 'if root==null: root=node', 'else: level-order find first free child', 'attach node as left/right child'],
            'bst-insert': ['create node', 'if root==null: root=node', 'else if val < node.val: go left', 'else go right', 'attach node at null spot'],
            'avl-insert': ['standard BST insert', 'update height', 'check balance', 'apply rotations (LL, RR, LR, RL) if needed'],
            'bst-delete': ['find node', 'if two children: replace with inorder successor', 'remove node', 'update links'],
            'avl-delete': ['standard BST delete', 'update heights up the path', 'rebalance with rotations if needed'],
            'traversal': ['visit nodes in specified order', 'highlight each node during traversal']
        }
        function showPseudocode(key) { const lines = templates[key] || ['--']; pseudocodeEl.innerHTML = ''; lines.forEach((l, i) => { const d = document.createElement('div'); d.className = 'code-line'; d.textContent = l; d.dataset.idx = i; pseudocodeEl.appendChild(d) }) }

        randomBtn.addEventListener('click', () => { const arr = genRandomArray(parseInt(seedLen.value, 10) || 7); buildFromArray(arr); showPseudocode(treeTypeSel.value + '-insert'); logOp('Built random tree: ' + arr.join(', ')) })
        clearBtn.addEventListener('click', () => { engine = makeEngine(treeTypeSel.value); nodeToG.clear(); render(); showPseudocode(treeTypeSel.value + '-insert'); logOp('Cleared tree') })

        insertBtn.addEventListener('click', () => {
            const v = parseInt(customVal.value, 10); if (Number.isNaN(v)) return; const t = treeTypeSel.value; let inserted = null;
            if (t === 'binary') { inserted = engine.insertLevel(v); } else { inserted = engine.insert ? engine.insert(v) : null }
            render(); showPseudocode(t + '-insert'); logOp('Inserted ' + v);
            if (inserted) { const g = nodeToG.get(inserted._id); if (g) { const r = g.querySelector('rect'); r.classList.add('highlight'); setTimeout(() => r.classList.remove('highlight'), 800) } }
        })

        deleteBtn.addEventListener('click', () => { const v = parseInt(customVal.value, 10); if (Number.isNaN(v)) return; const t = treeTypeSel.value; if (t === 'binary') { engine.delete(v) } else { engine.delete(v) } render(); showPseudocode(t + '-delete'); logOp('Deleted ' + v) })

        travBtn.addEventListener('click', () => {
            if (!engine.root) return; const t = travType.value; let arr = []; if (t === 'inorder') arr = inorderArr(); if (t === 'preorder') arr = preorderArr(); if (t === 'postorder') arr = postorderArr(); showPseudocode('traversal'); highlightSequence(arr, t);
        })

        speedRange.addEventListener('input', () => { speedVal.textContent = speedRange.value; if (animTimer) { clearInterval(animTimer); animTimer = null } })

        showPseudocode('binary-insert'); render();

    </script>
</body>


</html>
