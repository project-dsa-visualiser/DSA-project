<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dijkstra Algorithm Visualizer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400..700;1,400..700&family=Open+Sans:wght@400;600&display=swap" rel="stylesheet">
    
    <style>
       
        body {
            font-family: 'Lora', Georgia, serif;
            background-color: #e0f2f1; 
            color: #333;
            margin: 0;
            padding: 0;
            padding-bottom: 20px;
            overflow-x: hidden; 
        }

        h1, h2, h3 {
            color: #00796b; 
            margin-top: 0;
        }

        button,
        select {
            width: 100%;
            padding: 10px;
            border: 1px solid #80cbc4; 
            border-radius: 5px;
            background-color: #b2dfdb; 
            cursor: pointer;
            font-family: 'Open Sans', sans-serif;
            font-size: 14px;
            transition: all 0.2s ease;
            box-sizing: border-box; 
        }
        
        input[type="text"]:disabled {
             background-color: #e8f5e9;
             color: #00796b;
             font-weight: 600;
             border-color: #b2dfdb;
        }

        button {
            background-color: #26a69a;
            padding: 10px; 
            color: white;
            font-weight: 600;
            border: none;
        }

        button:hover:not(:disabled) {
            background-color: #00796b;
        }

        button:disabled {
            background-color: #b2dfdb;
            color: #e0f2f1;
            cursor: not-allowed;
        }

        input[type="text"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #80cbc4;
            border-radius: 5px;
            background-color: #fff;
            box-sizing: border-box;
            font-family: 'Open Sans', sans-serif;
            font-size: 14px;
        }
        
        .playback-controls {
            display: flex;
            gap: 5px;
        }

        hr {
            border: 0;
            border-top: 2px solid #b2dfdb;
            margin: 20px 0;
        }
        
        .toggle-switch {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .toggle-switch label {
            font-family: 'Open Sans', sans-serif;
            font-weight: 600;
            color: #555;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        .switch input { 
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: #26a69a;
        }
        input:checked + .slider:before {
            transform: translateX(26px);
        }

        
        .container-grid {
            display: grid;
            grid-template-columns: 300px 1fr 350px;
            grid-template-rows: [main-start] calc(100vh - 40px) [main-end];
            gap: 10px;
            padding: 10px;
            box-sizing: border-box;
            min-height: 100vh;
        }

        .controls-panel,
        .visualization-panel-wrapper, 
        .info-panel {
            background-color: #ffffff;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
            grid-row: main-start / main-end;
        }

        .visualization-panel-wrapper {
            display: flex;
            flex-direction: column;
            padding: 0; 
        }

        .visualization-panel {
            overflow: hidden;
            padding: 10px; 
            box-shadow: none;
            border-radius: 0;
            flex-grow: 1; 
            position: relative; 
        }
        
        #data-structure-display {
            flex-shrink: 0;
            padding: 10px 20px; 
            border-top: 2px solid #e0f2f1;
        }
        #data-structure-display h3 {
            margin-bottom: 5px;
        }
        #data-structure-status {
            font-family: 'Courier New', Courier, monospace;
            font-size: 1rem;
            font-weight: 600;
            color: #00796b;
            word-wrap: normal; 
            overflow-x: auto;
            white-space: nowrap; 
            padding-bottom: 5px;
        }

        .info-panel {
            display: flex;
            flex-direction: column;
        }

        .status-box {
            flex-shrink: 0;
        }

        .code-display {
            background-color: #e8f5e9; 
            border: 1px solid #b2dfdb;
            border-radius: 5px;
            padding: 10px;
            font-family: 'Courier New', Courier, monospace;
            flex-shrink: 0; 
            margin-top: 15px; 
        }
        
        .representation-box {
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.85rem;
            white-space: pre-wrap; 
            background: #e8f5e9;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #b2dfdb;
         
            margin-top: 15px; 
        }
        .representation-box h3 {
            margin-top: 0;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
            font-family: 'Open Sans', sans-serif;
        }

        .code-line {
            padding: 2px 5px;
            border-radius: 3px;
            transition: background-color 0.2s ease;
            white-space: pre-wrap;
            font-size: 0.9rem;
        }

        .code-line.highlight {
            background-color: #fffde7; 
        }

        #status-log {
            font-size: 14px;
            color: #333;
            height: 120px; 
            background: #e8f5e9; 
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #b2dfdb;
            transition: all 0.3s ease;
            overflow-y: auto; 
            font-family: 'Open Sans', sans-serif;
        }
        #status-log div {
            padding: 2px 0;
            border-bottom: 1px dashed #b2dfdb;
        }
        #status-log div:last-child {
            border-bottom: none;
        }

        #visualization-svg {
            width: 100%;
            height: 100%;
            display: block;
        }

        .edge {
            stroke: #000000;
            stroke-width: 2;
            transition: all 0.3s ease;
        }

        .edge.traversed {
            stroke: #ffb74d;
            stroke-width: 4;
        }
        
        .edge.in-path {
            stroke: #d81b60; 
            stroke-width: 5;
        }
        
        .edge-weight {
            font-size: 14px;
            font-family: 'Open Sans', sans-serif;
            fill: #d81b60; 
            font-weight: 600;
            text-anchor: middle;
            pointer-events: none;
            paint-order: stroke;
            stroke: #ffffff;
            stroke-width: 3px;
            stroke-linecap: butt;
            stroke-linejoin: miter;
        }
        
        .node circle {
            stroke: #26a69a; 
            stroke-width: 3;
            fill: #b2dfdb;
            transition: all 0.3s ease;
        }

        .node text {
            font-size: 16px;
            font-weight: 600;
            fill: #222;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
            user-select: none;
            font-family: 'Open Sans', sans-serif;
        }
        
        .node-label {
            font-size: 12px;
            font-family: 'Open Sans', sans-serif;
            fill: #004d40;
            font-weight: 600;
            text-anchor: middle;
            pointer-events: none;
            transition: all 0.3s ease;
        }
        
        .node.visited circle {
            fill: #fffde7; 
            stroke: #ffd54f;
        }

        .node.current circle {
            fill: #ffb74d;
            stroke: #fb8c00;
            stroke-width: 4;
        }

        .node.in-data-structure circle {
            fill: #ffcc80; 
            stroke: #fb8c00;
        }
        
        .node.in-path circle {
            fill: #fce4ec; 
            stroke: #d81b60; 
            stroke-width: 4;
        }

    </style>
</head>
<body>
    <div class="container-grid">
        <div class="controls-panel">
            <h2>Dijkstra Visualizer</h2>
            
            <div class="control-group">
                <button id="random-btn">New Random Graph</button>
            </div>
            
            <div class="control-group toggle-switch">
                <label for="directed-toggle">Directed Graph</label>
                <label class="switch">
                    <input type="checkbox" id="directed-toggle">
                    <span class="slider"></span>
                </label>
            </div>
            
            <div class="control-group">
                <label for="node-count-select">Node Count:</label>
                <select id="node-count-select">
                    <option value="4">4 Nodes</option>
                    <option value="5">5 Nodes</option>
                    <option value="6" selected>6 Nodes</option>
                    <option value="7">7 Nodes</option>
                    <option value="8">8 Nodes</option>
                </select>
            </div>
            
            <hr>
            
            <div class="control-group">
                <label>Algorithm:</label>
                <input type="text" value="Dijkstra's Shortest Path" disabled>
            </div>
            <div class="control-group">
                <label for="start-node-select">Start Node:</label>
                <select id="start-node-select"></select>
            </div>
            
            <div class="control-group" id="end-node-group">
                <label for="end-node-select">End Node:</label>
                <select id="end-node-select"></select>
            </div>
            
            <div class="control-group">
                <button id="start-btn">Start</button>
            </div>
            
            <hr>

            <h3>Playback</h3>
            <div class="control-group playback-controls">
                <button id="play-pause-btn">Play</button>
                <button id="step-btn">Next Step</button>
                <button id="reset-btn">Reset</button>
            </div>
            <div class="control-group">
                <label for="speed-slider">Animation Speed:</label>
                <input type="range" id="speed-slider" min="100" max="2000" value="1000" step="100">
            </div>
        </div>

        <div class="visualization-panel-wrapper">
            <div class="visualization-panel">
                <svg id="visualization-svg"></svg>
            </div>
            <div id="data-structure-display">
                <h3 id="data-structure-title">Priority Queue</h3>
                <div id="data-structure-status">[ ]</div>
            </div>
        </div>

        <div class="info-panel">
            <div class="status-box">
                <h3>Status Log</h3>
                <div id="status-log">
                    <div>Generated a random graph.</div>
                </div>
            </div>

            <div class="representation-box" id="adj-list-display-box">
                <h3>Adjacency List (weights in bracket)</h3>
                <div id="adj-list-display"></div>
            </div>

            <div class="code-display" id="code-display">
                <h3 id="code-title">Dijkstra Pseudocode</h3>
                
                <div id="dijkstra-code">
                    <div class="code-line" id="dij-line-1">1. <span><b>Dijkstra</b>(graph, start, end)</span></div>
                    <div class="code-line" id="dij-line-2">2. &nbsp;&nbsp;<span>create dist map, all nodes to ∞</span></div>
                    <div class="code-line" id="dij-line-3">3. &nbsp;&nbsp;<span>create prev map, all nodes to null</span></div>
                    <div class="code-line" id="dij-line-4">4. &nbsp;&nbsp;<span>create PriorityQueue (pq)</span></div>
                    <div class="code-line" id="dij-line-5">5. &nbsp;&nbsp;<span>dist[start] = 0</span></div>
                    <div class="code-line" id="dij-line-6">6. &nbsp;&nbsp;<span>pq.enqueue(start, 0)</span></div>
                    <div class="code-line" id="dij-line-7">7. &nbsp;&nbsp;<span>while (pq is not empty)</span></div>
                    <div class="code-line" id="dij-line-8">8. &nbsp;&nbsp;&nbsp;&nbsp;<span>let node = pq.dequeue()</span></div>
                    <div class="code-line" id="dij-line-9">9. &nbsp;&nbsp;&nbsp;&nbsp;<span>if (node == end) break</span></div>
                    <div class="code-line" id="dij-line-10">10. &nbsp;&nbsp;&nbsp;&nbsp;<span>for (neighbor of node.neighbors)</span></div>
                    <div class="code-line" id="dij-line-11">11. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>let newDist = dist[node] + weight</span></div>
                    <div class="code-line" id="dij-line-12">12. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>if (newDist < dist[neighbor])</span></div>
                    <div class="code-line" id="dij-line-13">13. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>dist[neighbor] = newDist</span></div>
                    <div class="code-line" id="dij-line-14">14. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>prev[neighbor] = node</span></div>
                    <div class="code-line" id="dij-line-15">15. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>pq.enqueue(neighbor, newDist)</span></div>
                    <div class="code-line" id="dij-line-16">16. &nbsp;&nbsp;<span>// Reconstruct path from end</span></div>
                </div>
            </div>
            
            
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const svg = document.getElementById('visualization-svg');
            const randomBtn = document.getElementById('random-btn');
            const directedToggle = document.getElementById('directed-toggle');
            const nodeCountSelect = document.getElementById('node-count-select'); 
            const startNodeSelect = document.getElementById('start-node-select');
            const endNodeGroup = document.getElementById('end-node-group');
            const endNodeSelect = document.getElementById('end-node-select');
            const startBtn = document.getElementById('start-btn');
            
            const playPauseBtn = document.getElementById('play-pause-btn');
            const stepBtn = document.getElementById('step-btn');
            const resetBtn = document.getElementById('reset-btn');
            const speedSlider = document.getElementById('speed-slider');
            
            const statusLog = document.getElementById('status-log'); 
            const dataStructureTitle = document.getElementById('data-structure-title');
            const dataStructureStatus = document.getElementById('data-structure-status');
            const adjListDisplay = document.getElementById('adj-list-display');
            
            
            const codeTitle = document.getElementById('code-title');
            const dijkstraCode = document.getElementById('dijkstra-code');
            const allCodeLines = document.querySelectorAll('.code-line');

            let graph = { nodes: [], edges: [] }; 
            let adjList = new Map(); 
            let isDirected = false;
            let animationSteps = [];
            let currentStep = 0;
            let animationSpeed = 1000;
            let isPlaying = false;
            let animationInterval = null;
            
            
            class PriorityQueue {
                constructor() { this.nodes = []; }
                enqueue(node, priority) {
                    this.nodes.push({ node, priority });
                    this.sort();
                }
                dequeue() { 
                    if(this.isEmpty()) return null;
                    return this.nodes.shift().node; 
                }
                sort() { this.nodes.sort((a, b) => a.priority - b.priority); }
                isEmpty() { return !this.nodes.length; }
                getDisplayString() {
                    return this.nodes.map(n => `${n.node}(${n.priority})`).join(', ');
                }
            }
            
            const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
            const updateSpeed = () => { animationSpeed = 2100 - speedSlider.value; };

            function setStatus(message) {
                const logEntry = document.createElement('div');
                logEntry.textContent = message;
                statusLog.appendChild(logEntry);
                statusLog.scrollTop = statusLog.scrollHeight;
            }
            function clearStatus() {
                statusLog.innerHTML = '';
            }

            function clearHighlights() {
                allCodeLines.forEach(line => line.classList.remove('highlight'));
            }
            

            function generateRandomGraph() {
                graph = { nodes: [], edges: [] };
                
                const numNodes = parseInt(nodeCountSelect.value, 10);
                const nodeIds = Array.from({ length: numNodes }, (_, i) => String.fromCharCode(65 + i));
                
                const svgPanel = document.querySelector('.visualization-panel');
                if (!svgPanel) return; 
                const SVG_WIDTH = svgPanel.clientWidth;
                const SVG_HEIGHT = svgPanel.clientHeight;
                
                const MIN_DISTANCE = 250; 
                const MARGIN = 40;

                for (const id of nodeIds) {
                    let placed = false;
                    let x, y;
                    for (let i = 0; i < 100; i++) {
                        x = Math.random() * (SVG_WIDTH - MARGIN * 2) + MARGIN;
                        y = Math.random() * (SVG_HEIGHT - MARGIN * 2) + MARGIN;
                        
                        let tooClose = false;
                        for (const node of graph.nodes) {
                            const dist = Math.sqrt(Math.pow(node.x - x, 2) + Math.pow(node.y - y, 2));
                            if (dist < MIN_DISTANCE) {
                                tooClose = true;
                                break;
                            }
                        }
                        
                        if (!tooClose) {
                            placed = true;
                            break;
                        }
                    }
                    graph.nodes.push({ id, x: x || 50, y: y || 50 });
                }

                for (let i = 0; i < numNodes; i++) {
                    for (let j = i + 1; j < numNodes; j++) {
                        if (Math.random() > 0.4) { 
                            graph.edges.push({
                                source: nodeIds[i],
                                target: nodeIds[j],
                                weight: Math.floor(Math.random() * 10) + 1 
                            });
                        }
                    }
                }
                
                if (graph.edges.length === 0 && numNodes > 1) {
                    graph.edges.push({
                        source: nodeIds[0],
                        target: nodeIds[1],
                        weight: Math.floor(Math.random() * 10) + 1
                    });
                }

                buildAdjList();
                drawGraph();
                updateNodeSelects();
                displayGraphRepresentations();
                resetAnimation(false); 
                clearStatus(); 
                setStatus(`New ${numNodes}-node weighted graph generated. Ready.`);
            }
            
            function buildAdjList() {
                adjList.clear();
                for (const node of graph.nodes) {
                    adjList.set(node.id, []);
                }
                for (const edge of graph.edges) {
                    if(adjList.has(edge.source)) {
                        adjList.get(edge.source).push({ node: edge.target, weight: edge.weight });
                    }
                    if (!isDirected) {
                         if(adjList.has(edge.target)) {
                            adjList.get(edge.target).push({ node: edge.source, weight: edge.weight });
                         }
                    }
                }
            }

            function updateNodeSelects() {
                startNodeSelect.innerHTML = '';
                endNodeSelect.innerHTML = ''; 
                
                const sortedNodes = [...graph.nodes].sort((a,b) => a.id.localeCompare(b.id));
                for (const node of sortedNodes) {
                    const option1 = document.createElement('option');
                    option1.value = node.id;
                    option1.textContent = node.id;
                    startNodeSelect.appendChild(option1);
                    endNodeSelect.appendChild(option1.cloneNode(true));
                }
                if(sortedNodes.length > 1) {
                    endNodeSelect.value = sortedNodes[1].id;
                }
            }

            function displayGraphRepresentations() {
         
                let listString = "";
                const sortedNodes = [...adjList.keys()].sort();
                for (const nodeId of sortedNodes) {
                    listString += `${nodeId}: `;
                    const neighbors = adjList.get(nodeId) || []; 
                    if (neighbors.length === 0) {
                        listString += "null\n";
                    } else {
                        listString += neighbors
                            .map(n => `${n.node}(${n.weight})`)
                            .sort()
                            .join(', ') + '\n';
                    }
                }
                adjListDisplay.textContent = listString;
            }

            function drawGraph() {
                svg.innerHTML = ''; 
                
                const svgPanel = document.querySelector('.visualization-panel');
                if (!svgPanel) return; 
                const SVG_WIDTH = svgPanel.clientWidth;
                const SVG_HEIGHT = svgPanel.clientHeight;
                if(SVG_WIDTH === 0 || SVG_HEIGHT === 0) return; 
                
                svg.setAttribute("viewBox", `0 0 ${SVG_WIDTH} ${SVG_HEIGHT}`);
                
                const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                
                if (isDirected) {
                    defs.innerHTML = `
                        <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                        refX="9" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#000000" />
                        </marker>
                    `;
                }
                
                svg.appendChild(defs);

                const edgeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                const nodeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                
                graph.edges.forEach((edge, index) => {
                    const sourceNode = graph.nodes.find(n => n.id === edge.source);
                    const targetNode = graph.nodes.find(n => n.id === edge.target);
                    
                    if (!sourceNode || !targetNode) return; 

                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    
                    let x1 = sourceNode.x;
                    let y1 = sourceNode.y;
                    let x2 = targetNode.x;
                    let y2 = targetNode.y;
                    
                    const midX = (x1 + x2) / 2;
                    const midY = (y1 + y2) / 2;
                    
                    const angle = Math.atan2(y2 - y1, x2 - x1);
                    const offsetX = Math.sin(angle) * 15; 
                    const offsetY = -Math.cos(angle) * 15; 


                    if (isDirected) {
                        const dx = x2 - x1;
                        const dy = y2 - y1;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist > 0) { 
                            const ratio = (dist - 23) / dist; 
                            x2 = x1 + dx * ratio;
                            y2 = y1 + dy * ratio;
                        }
                    }

                    line.setAttribute('x1', x1);
                    line.setAttribute('y1', y1);
                    line.setAttribute('x2', x2);
                    line.setAttribute('y2', y2);
                    line.setAttribute('class', 'edge');
                    line.setAttribute('id', `edge-${edge.source}-${edge.target}`);
                    if (isDirected) {
                        line.setAttribute('marker-end', 'url(#arrowhead)');
                    }
                    edgeGroup.appendChild(line);
                    
                    const weightText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    weightText.setAttribute('x', midX + offsetX);
                    weightText.setAttribute('y', midY + offsetY); 
                    weightText.setAttribute('class', 'edge-weight'); 
                    weightText.textContent = edge.weight;
                    edgeGroup.appendChild(weightText);
                });

                graph.nodes.forEach(node => {
                    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    g.setAttribute('class', 'node');
                    g.setAttribute('id', `node-${node.id}`);

                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', node.x);
                    circle.setAttribute('cy', node.y);
                    circle.setAttribute('r', 20);
                    
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', node.x);
                    text.setAttribute('y', node.y);
                    text.textContent = node.id;
                    
                    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    
                    const labelY = (node.y < SVG_HEIGHT / 2) ? node.y - 32 : node.y + 32;

                    label.setAttribute('x', node.x);
                    label.setAttribute('y', labelY); 
                    label.setAttribute('class', 'node-label');
                    label.setAttribute('id', `node-label-${node.id}`);
                    label.textContent = 'dist: ∞'; 
                    
                    g.appendChild(circle);
                    g.appendChild(text);
                    g.appendChild(label); 
                    nodeGroup.appendChild(g);
                });
                
                svg.appendChild(edgeGroup);
                svg.appendChild(nodeGroup);
            }
            

            function createStep(message, codeLine, visualState) {
                return { message, codeLine, visualState };
            }
            
            function generateDijkstraSteps(startNodeId, endNodeId) {
                let steps = [];
                let distances = new Map();
                let prev = new Map();
                let pq = new PriorityQueue();
                
                steps.push(createStep('Starting Dijkstra', 'dij-line-1', {}));
                steps.push(createStep('Initializing distances to Infinity', 'dij-line-2', {}));
                for (const node of graph.nodes) {
                    distances.set(node.id, Infinity);
                    prev.set(node.id, null);
                }
                
                steps.push(createStep('Initializing Previous map', 'dij-line-3', {}));
                steps.push(createStep('Creating Priority Queue', 'dij-line-4', {}));
                
                distances.set(startNodeId, 0);
                steps.push(createStep(`Set start node ${startNodeId} distance to 0.`, 'dij-line-5', { label: {id: startNodeId, dist: 0} }));
                
                pq.enqueue(startNodeId, 0);
                steps.push(createStep(`Enqueue ${startNodeId} with priority 0.`, 'dij-line-6', { dsText: pq.getDisplayString(), inDS: startNodeId }));
                
                steps.push(createStep('While Priority Queue is not empty...', 'dij-line-7', {}));

                while (!pq.isEmpty()) {
                    let nodeId = pq.dequeue();
                    if(nodeId === null) break; 
                    
                    if (distances.get(nodeId) === Infinity) {
                        steps.push(createStep(`Skipping ${nodeId} (already processed).`, '', {}));
                        continue; 
                    }
                    
                    steps.push(createStep(`Dequeue ${nodeId} (priority ${distances.get(nodeId)}).`, 'dij-line-8', { current: nodeId, dsText: pq.getDisplayString() }));
                    
                    steps.push(createStep(`Mark ${nodeId} as visited.`, '', { visited: new Set([nodeId]) }));

                    if (nodeId === endNodeId) {
                        steps.push(createStep(`Reached end node ${endNodeId}. Path found.`, 'dij-line-9', {}));
                        break;
                    }
                    
                    steps.push(createStep(`Checking neighbors of ${nodeId}...`, 'dij-line-10', {}));
                    const neighbors = (adjList.get(nodeId) || []).sort((a,b) => a.node.localeCompare(b.node));
                    
                    for (const neighborObj of neighbors) {
                        const neighbor = neighborObj.node;
                        const weight = neighborObj.weight;
                        steps.push(createStep(`Checking neighbor ${neighbor} with weight ${weight}...`, '', { edge: [nodeId, neighbor] }));
                        
                        const newDist = distances.get(nodeId) + weight;
                        steps.push(createStep(`New path to ${neighbor}: ${distances.get(nodeId)} + ${weight} = ${newDist}.`, 'dij-line-11', {}));

                        if (newDist < distances.get(neighbor)) {
                            steps.push(createStep(`Shorter path found! (${newDist} < ${distances.get(neighbor)})`, 'dij-line-12', {}));
                            
                            distances.set(neighbor, newDist);
                            steps.push(createStep(`Update ${neighbor} distance to ${newDist}.`, 'dij-line-13', { label: {id: neighbor, dist: newDist} }));
                            
                            prev.set(neighbor, nodeId);
                            steps.push(createStep(`Set ${neighbor}'s predecessor to ${nodeId}.`, 'dij-line-14', {}));
                            
                            pq.enqueue(neighbor, newDist);
                            steps.push(createStep(`Enqueue ${neighbor} with priority ${newDist}.`, 'dij-line-15', { dsText: pq.getDisplayString(), inDS: neighbor }));
                        } else {
                             steps.push(createStep(`Not a shorter path. (${newDist} >= ${distances.get(neighbor)})`, 'dij-line-12', {}));
                        }
                    }
                }
                
                steps.push(createStep('Algorithm finished. Reconstructing path...', 'dij-line-16', {}));
                let path = [];
                let current = endNodeId;
                let pathExists = true;
                
                if (distances.get(endNodeId) === Infinity) {
                    pathExists = false;
                } else {
                    while (current) {
                        path.unshift(current);
                        if (current === startNodeId) break; 
                        current = prev.get(current);
                        if (!current && path[0] !== startNodeId) {
                            pathExists = false; 
                            break;
                        }
                    }
                }
                
                if (pathExists && path[0] === startNodeId) {
                     steps.push(createStep(`Shortest path: ${path.join(' -> ')} (Cost: ${distances.get(endNodeId)})`, '', { path: path }));
                } else {
                     steps.push(createStep(`No path found from ${startNodeId} to ${endNodeId}.`, '', {}));
                }

                return steps;
            }


            function play() {
                if (isPlaying || currentStep >= animationSteps.length) return;
                isPlaying = true;
                playPauseBtn.textContent = 'Pause';
                playPauseBtn.classList.add('playing');
                
                animationInterval = setInterval(() => {
                    executeStep();
                    if (currentStep >= animationSteps.length) {
                        pause();
                    }
                }, animationSpeed);
            }

            function pause() {
                isPlaying = false;
                playPauseBtn.textContent = 'Play';
                playPauseBtn.classList.remove('playing');
                clearInterval(animationInterval);
                animationInterval = null;
            }
            
            function playPause() {
                if (isPlaying) pause();
                else play();
            }

            function stepForward() {
                if (currentStep < animationSteps.length) {
                    pause();
                    executeStep();
                }
            }

            function executeStep() {
                if (currentStep >= animationSteps.length) {
                    pause();
                    return;
                }
                const step = animationSteps[currentStep];
                renderStep(step);
                currentStep++;
            }

            function resetAnimation(clearLog = true) {
                pause();
                animationSteps = [];
                currentStep = 0;
                resetVisualState();
                setControlsDisabled(false);
                if (clearLog) {
                    clearStatus();
                    setStatus('Ready.');
                }
                dataStructureStatus.textContent = '[ ]';
                graph.nodes.forEach(node => {
                    const label = document.getElementById(`node-label-${node.id}`);
                    if(label) label.textContent = 'dist: ∞';
                });
            }
            
            function resetVisualState() {
                document.querySelectorAll('.node').forEach(n => n.classList.remove('current', 'visited', 'in-data-structure', 'in-path'));
                document.querySelectorAll('.edge').forEach(e => e.classList.remove('traversed', 'in-path'));
                clearHighlights();
            }


            function renderStep(step) {
                const { message, codeLine, visualState } = step;

                setStatus(message);
                
                clearHighlights();
                if (codeLine) {
                    const el = document.getElementById(codeLine);
                    if (el) el.classList.add('highlight');
                }

                document.querySelectorAll('.node.current').forEach(n => n.classList.remove('current'));
                document.querySelectorAll('.edge.traversed').forEach(e => e.classList.remove('traversed'));
                document.querySelectorAll('.node.in-data-structure').forEach(n => n.classList.remove('in-data-structure'));

                if (visualState.dsText !== undefined) {
                    dataStructureStatus.textContent = `[ ${visualState.dsText} ]`;
                }
                
                if (visualState.current) {
                    const el = document.getElementById(`node-${visualState.current}`);
                    if (el) el.classList.add('current');
                }
                if (visualState.inDS) {
                    const el = document.getElementById(`node-${visualState.inDS}`);
                    if (el) el.classList.add('in-data-structure');
                }
                
                if (visualState.visited) {
                    visualState.visited.forEach(nodeId => {
                        const el = document.getElementById(`node-${nodeId}`);
                        if (el) el.classList.add('visited');
                    });
                }
                
                if (visualState.edge) {
                    const [u, v] = visualState.edge;
                    let edgeEl = document.getElementById(`edge-${u}-${v}`) || (isDirected ? null : document.getElementById(`edge-${v}-${u}`));
                    if (edgeEl) edgeEl.classList.add('traversed');
                }
                
                if (visualState.label) {
                    const label = document.getElementById(`node-label-${visualState.label.id}`);
                    if (label) label.textContent = `dist: ${visualState.label.dist}`;
                }
                
                if (visualState.path) {
                    for (let i = 0; i < visualState.path.length; i++) {
                        const nodeId = visualState.path[i];
                        document.getElementById(`node-${nodeId}`)?.classList.add('in-path');
                        
                        if (i < visualState.path.length - 1) {
                            const nextNodeId = visualState.path[i+1];
                            let edgeEl = document.getElementById(`edge-${nodeId}-${nextNodeId}`) || (isDirected ? null : document.getElementById(`edge-${nextNodeId}-${nodeId}`));
                            if (edgeEl) edgeEl.classList.add('in-path');
                        }
                    }
                }
            }

            
            function setControlsDisabled(disabled) {
                isAnimating = disabled;
                startBtn.disabled = disabled;
                randomBtn.disabled = disabled;
                directedToggle.disabled = disabled;
                nodeCountSelect.disabled = disabled;
                startNodeSelect.disabled = disabled;
                endNodeSelect.disabled = disabled; 
               
            }

            startBtn.addEventListener('click', () => {
                if (isAnimating) return;
                
                const startNodeId = startNodeSelect.value;
                const endNodeId = endNodeSelect.value; 
                
                if (!startNodeId || !endNodeId) {
                    setStatus('Error: Must select a Start and End node.');
                    return;
                }
                
                if (startNodeId === endNodeId) {
                    setStatus('Error: Start and End nodes must be different.');
                    return;
                }

                setControlsDisabled(true);
                resetVisualState();
                clearStatus(); 
                
                graph.nodes.forEach(node => {
                    const label = document.getElementById(`node-label-${node.id}`);
                    if(label) label.textContent = 'dist: ∞';
                });
                
                animationSteps = generateDijkstraSteps(startNodeId, endNodeId);
                
                currentStep = 0;
                play();
            });

            randomBtn.addEventListener('click', generateRandomGraph);
            nodeCountSelect.addEventListener('change', generateRandomGraph); 
            
            directedToggle.addEventListener('change', (e) => {
                isDirected = e.target.checked;
                buildAdjList();
                drawGraph();
                displayGraphRepresentations();
                resetAnimation(true); 
                setStatus(`Graph set to ${isDirected ? 'Directed' : 'Undirected'}.`);
            });
            
            playPauseBtn.addEventListener('click', playPause);
            stepBtn.addEventListener('click', stepForward);
            resetBtn.addEventListener('click', () => resetAnimation(true)); 
            speedSlider.addEventListener('input', updateSpeed);
            updateSpeed();
            generateRandomGraph(); 
        });
    </script>
</body>
</html>